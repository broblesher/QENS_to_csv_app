{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation for QENS to csv App","text":""},{"location":"#about","title":"About","text":"<p>QENS to csv App is a project developed by Beatriz Robles. The App launches a DLG to browse QENS data recorded in  several instruments, parse the data files, sort the data in a matrix form and export it to a csv file.</p> <p>You can learn how to use the App following this tutorial.</p>"},{"location":"#instruments","title":"Instruments","text":"<p>QENS to csv App works with data from IN5, IN16B, FOCUS and LET.</p>"},{"location":"#further-information","title":"Further information","text":"<p>You can learn how to use QENS to cvs App following this tutorial.</p> <p>You can find the project documentation here, and here.</p>"},{"location":"ref-funcionesleer/","title":"Ref. FuncionesLeer","text":"<p>FuncionesLeer class.</p> <p>Filename: FuncionesLeer.py Author: Beatriz Robles Hern\u00e1ndez Date: 2025-03-10 Version: 1.0 Description:     This module contains a class with the functions     necesary to read from data files, save data in     pandas data frames, and write data to csv files.</p> <p>License: GLP Contact: broblesher@gmail.com Dependencies: os, _io, pandas, matplotlip.pyplot, numpy, numpy.typing</p>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer","title":"<code>FuncionesLeer</code>","text":"<p>FuncionesLeer class.</p> <p>A class used to colect the methos to read QENS data from text file, transform the data into a matrix, and write it to a csv file.</p> <p>Methods:</p> Name Description <code>fileNameDropLET</code> <p>Trims the filenames of the LET input file</p> <code>check_path</code> <p>Checks if the path exist</p> <code>open_iFile</code> <p>Opens the data file</p> <code>close_iFile</code> <p>Closes the data file</p> <code>leer_de_IN5</code> <p>Parses the IN5 data files</p> <code>leer_de_IN16B</code> <p>Parses the IN16B data files</p> <code>leer_de_FOCUS</code> <p>Parses the FOCUS data files</p> <code>leer_de_LET</code> <p>Parses the LET data files</p> <code>read_from_ifile</code> <p>Reads from input files and saves the data in lists</p> <code>data_to_pandas_df</code> <p>Saves S(Q, E) data in a pandas DataFrame.</p> <code>chi_from_S</code> <p>Calculates Chi(Q, E) from S(Q, E) at a given T</p> <code>save_data_to_csv</code> <p>Saves the data in the S(Q, E) pandas.DataFrame to a csv file.</p> <code>save_chi_data_to_csv</code> <p>Saves the data in the Chi(Q, E) pandas.DataFrame to a csv file.</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>class FuncionesLeer:\n    \"\"\"FuncionesLeer class.\n\n    A class used to colect the methos to read QENS data from text file,\n    transform the data into a matrix, and write it to a csv file.\n\n    Methods\n    -------\n    fileNameDropLET(iFileName)\n        Trims the filenames of the LET input file\n    check_path(path)\n        Checks if the path exist\n    open_iFile(fileName)\n        Opens the data file\n    close_iFile(iFile)\n        Closes the data file\n    leer_de_IN5(iFile:, qvalue,energy, scatInt, err)\n        Parses the IN5 data files\n    leer_de_IN16B(iFile:, qvalue,energy, scatInt, err)\n        Parses the IN16B data files\n    leer_de_FOCUS(iFile:, qvalue,energy, scatInt, err)\n        Parses the FOCUS data files\n    leer_de_LET(iFileName)\n        Parses the LET data files\n    read_from_ifile(iFile, instrument)\n        Reads from input files and saves the data in lists\n    data_to_pandas_df(fileName, qvalue, energy, scatInt, err)\n        Saves S(Q, E) data in a pandas DataFrame.\n    chi_from_S(temp, qvalue, dfS)\n        Calculates Chi(Q, E) from S(Q, E) at a given T\n    save_data_to_csv(oFileName, dfS)\n        Saves the data in the S(Q, E) pandas.DataFrame to a csv file.\n    save_chi_data_to_csv(oFileName, dfchiSorted)\n        Saves the data in the Chi(Q, E) pandas.DataFrame to a csv file.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Class constructor.\"\"\"\n        print('FuncionesLeer constructor')\n\n    def fileNameDropLET(self, iFileName: str) -&gt; str:\n        \"\"\"Trim LET files names.\n\n        Trims the filenames of the LET input file to find all the\n        files begining with the same characters, belonging to the\n        same measurement.\n\n        Parameters\n        ----------\n        iFileName:\n            the filename, icluding the path\n\n        Returns\n        -------\n        fileName: str\n            the filename, excluding the path\n\n        Other parameters\n        ---------\n        firstParethesisPos: int\n            the position in fileName of the first parenthesis\n        charDrop: int\n            the number of characters (at the endo of the filename)\n            to delete\n        \"\"\"\n        fileName: str\n        fileName = os.path.basename(iFileName)  # quita la ruta (path)\n        firstParethesisPos: int\n        # busco la primera aparici\u00f3n de el par\u00e9ntesis\n        firstParethesisPos = fileName.index('(')\n        charDrop: int\n        # calculo el n\u00famero de caracteres que quiero eliminar\n        charDrop = len(fileName) - firstParethesisPos\n        fileName = fileName[:-charDrop]\n        return fileName\n\n    def check_path(self, path: str) -&gt; bool:\n        \"\"\"Check if the path exist.\n\n        Parameters\n        ----------\n        path: str\n            the input path\n\n        Raises\n        ------\n        IOError\n        \"\"\"\n        if not os.path.exists(os.path.dirname(path)):\n            raise IOError(2, 'Path does not exist. ')\n        else:\n            return True\n\n    def open_iFile(self, fileName: str) -&gt; _io.TextIOWrapper:\n        \"\"\"Open the data file.\n\n        Parameters\n        ----------\n        fileName: str\n            the data file to be open, with path included\n\n        Returns\n        -------\n        iFile: _io.TextIOWrapper\n            the object to which the open file is assigned\n\n        Raises\n        ------\n        err: IOError\n            the IOError to save the error\n        \"\"\"\n        # msg: str\n        iFile: _io.TextIOWrapper\n        try:\n            iFile = open(fileName, \"r\")  # abro el input file\n        except IOError:  # as err:\n            # msg = str(err.strerror)\n            raise OSError(2, 'Input file does not exist. ')\n            # return msg\n        else:\n            return iFile\n\n    def close_iFile(self, iFile: _io.TextIOWrapper) -&gt; bool:\n        \"\"\"Close the data file.\n\n        Parameters\n        ----------\n        iFile: _io.TextIOWrapper\n            the input object of the opened data file\n        \"\"\"\n        iFile.close()  # Cuando acabo de leer el fichero, lo cierro\n        if iFile.closed is False:\n            print(\"Error closing file!\")\n            return False\n        else:\n            print(\"File closed!\")\n            return True\n\n    def leer_de_IN5(self, iFile: _io.TextIOWrapper, qvalue: list[float],\n                    energy: list[list[float]], scatInt: list[list[float]],\n                    err: list[list[float]]) -&gt; tuple:\n        \"\"\"Parse the IN5 data files.\n\n        Parameters\n        ----------\n        iFile: _io.TextIOWrapper\n            the objecto with the input file open\n        qvalue: list[float]\n            the array with the Q values\n        energy: list[list[float]]\n            the array with the arays of measured energies,\n            for earch Q\n        scatInt: list[list[float]]\n            the array with the arays of measured intensities,\n            for earch Q\n        err: list[list[float]]\n            the array with the arays of measured errors,\n            for earch Q\n\n        Returns\n        -------\n        A tuple with the values:\n        qvalue: list[float]\n        energy: list[list[float]]\n        scatInt: list[list[float]]\n        err: list[list[float]]\n\n        Other parameters\n        ----------------\n        line: str\n            to read de file line by line\n        elements: list[str]\n            to save all the elements of a line in a list\n        numq: int\n            to Q iterator (contador de Q, para cambiar de Q)\n        \"\"\"\n        line: str\n        elements: list[str]\n        numq: int\n        numq = 0  # Pongo el contador de Q a cero\n\n        for line in iFile.readlines():\n            elements = line.split()  # Divido la l\u00ednea en elementos\n            if (len(elements) != 0):  # la l\u00ednea le\u00edda no est\u00e1 vac\u00eda\n                # Para IN5, si son 6, el primer elemento es la Q\n                if (len(elements) == 6):\n                    # a\u00f1ado la Q a la lista correspondiente\n                    qvalue.append(float(elements[0]))\n                    # a\u00f1ado una lista vac\u00eda a E, S(Q,E) y err\n                    energy.append([])\n                    scatInt.append([])\n                    err.append([])\n                    numq = numq + 1  # Sumo uno al contador de Q\n                # Si tengo 3 elementos en la l\u00ednea, son E, S(Q, E) y err\n                if (len(elements) == 3):\n                    # hay una linea chunga que no s\u00e9 que es y empieza por 0\n                    # la descarto\n                    if (float(elements[0]) != 0):\n                        # A\u00f1ado los valores a las listas correspondientes\n                        energy[numq - 1].append(float(elements[0]))\n                        scatInt[numq - 1].append(float(elements[1]))\n                        err[numq - 1].append(float(elements[2]))\n        return qvalue, energy, scatInt, err\n\n    def leer_de_IN16B(self, iFile: _io.TextIOWrapper, qvalue: list[float],\n                      energy: list[list[float]], scatInt: list[list[float]],\n                      err: list[list[float]]) -&gt; tuple:\n        \"\"\"Parse the IN16B data files.\n\n        Parameters\n        ----------\n        iFile: _io.TextIOWrapper\n            the object with the input file open\n        qvalue: list[float]\n            the array with the Q values\n        energy: list[list[float]]\n            the array with the arays of measured energies,\n            for earch Q\n        scatInt: list[list[float]]\n            the array with the arays of measured intensities,\n            for earch Q\n        err: list[list[float]]\n            the array with the arays of measured errors,\n            for earch Q\n\n        Returns\n        -------\n        A tuple with the values:\n        qvalue: list[float]\n        energy: list[list[float]]\n        scatInt: list[list[float]]\n        err: list[list[float]]\n\n        Other parameters\n        ----------------\n        line: str\n            to read de file line by line\n        elements: list[str]\n            to save all the elements of a line in a list\n        numq: int\n            to Q iterator (contador de Q, para cambiar de Q)\n        \"\"\"\n        line: str\n        elements: list[str]\n        numq: int\n        numq = 0  # Pongo el contador de Q a cero\n\n        for line in iFile.readlines():\n            elements = line.split()  # Divido la l\u00ednea en elementos\n            if (len(elements) != 0):  # la l\u00ednea le\u00edda no est\u00e1 vac\u00eda\n                # Para IN16B, busco la Q\n                if (elements[0] == \"#\" and elements[1] == \"q(Angstrom^-1)\"):\n                    # a\u00f1ado la Q a la lista correspondiente\n                    qvalue.append(float(elements[3]))\n                    # a\u00f1ado una lista vac\u00eda a E, S(Q,E) y err\n                    energy.append([])\n                    scatInt.append([])\n                    err.append([])\n                    numq = numq + 1  # Sumo uno al contador de Q\n                # Si hay elementos y no empiezan por #, son los datos\n                if (elements[0] != \"#\"):\n                    # A\u00f1ado los valores a la lista correspondiente\n                    energy[numq - 1].append(float(elements[0]))\n                    scatInt[numq - 1].append(float(elements[1]))\n                    err[numq - 1].append(float(elements[2]))\n        return qvalue, energy, scatInt, err\n\n    def leer_de_LET(self, iFileName: str) -&gt; tuple:\n        \"\"\"Parse the LET data files.\n\n        Parameters\n        ----------\n        iFileName: str\n            the input filename, with path\n\n        Returns\n        -------\n        A tuple with the values:\n        qvalue: list[float]\n        energy: list[list[float]]\n        scatInt: list[list[float]]\n        err: list[list[float]]\n\n        Other parameters\n        ----------------\n        qvalue: list[float]\n            the array with the Q values\n        energy: list[list[float]]\n            the array with the arays of measured energies,\n            for earch Q\n        scatInt: list[list[float]]\n            the array with the arays of measured intensities,\n            for earch Q\n        err: list[list[float]]\n            the array with the arays of measured errors,\n            for earch Q\n        line: str\n            to read de file line by line\n        elements: list[str]\n            to save all the elements of a line in a list\n        qlist: list[str]\n            to save the string of the line where the Q interval is\n        qmin: float\n            the minimum Q in the Q interval\n        qmax: float\n            the maximum Q in the Q interval\n        qcurr: float\n            the Q of the currently reading input file\n        numq: int\n            to Q iterator (contador de Q, para cambiar de Q)\n        filenames: list[str]\n            list with al the files in the folder\n        dirs: list[str]\n            list with the subdirectories in the folder\n        root: str\n            # me imagino que el path?\n        f: str\n        files: list[str]\n            the array where I save the file names that I want to read from\n        path: str\n            the path where the files are\n        iFile: _io.TextIOWrapper\n            the object with the input file open\n        \"\"\"\n        qvalue: list[float]\n        energy: list[list[float]]\n        scatInt: list[list[float]]\n        err: list[list[float]]\n        qvalue = []\n        energy = []\n        scatInt = []\n        err = []\n\n        line: str\n        elements: list[str]\n        qlist: list[str]\n        qmin: float  # la Q minima del intervalo\n        qmax: float  # la Q maxima del intervalo\n        qcurr: float  # la Q corespondiente al fichero q est\u00e1 leyendo\n        numq: int  # es el contador que voy a usar para cambiar de Q\n        numq = 0  # Pongo el contador de Q a cero\n        # Lo primero que tengo que hacer es buscar los ficheros que me\n        # interesan en la carpeta\n        filenames: list[str]  # la lista de todos los archivos en la carpeta\n        dirs: list[str]  # la lista de subdirectorios en la carpeta\n        root: str  # me imagino que el path?\n        f: str\n        files: list[str]\n        files = []\n        path: str\n        path = os.path.dirname(iFileName)\n        fileName = self.fileNameDropLET(iFileName)\n        for (root, dirs, filenames) in os.walk(path):\n            for f in filenames:\n                if fileName in f and '.txt' in f:\n                    files.append(f)\n\n        iFile: _io.TextIOWrapper\n        for f in files:\n            try:\n                iFile = self.open_iFile(path + '/' + f)\n            except IOError:  # as error:\n                pass\n                # pongo algo m\u00e1s? qu\u00e9 quiero que haga si no consigue\n                # abrir un fichero?\n            else:\n                for line in iFile.readlines():\n                    elements = line.split()  # Divido la l\u00ednea en elementos\n                    if (len(elements) != 0):  # Si la l\u00ednea le\u00edda no est\u00e1 vac\u00eda\n                        # Para LET la Q est\u00e1 en la l\u00ednea que empieza as\u00ed:\n                        if (elements[1] == \"Integration\"):\n                            qlist = elements[3].split(\",\")\n                            qmin = float(qlist[1])\n                            qmax = float(qlist[2])\n                            qcurr = qmin + (qmax - qmin) / 2\n                            # a\u00f1ado la Q a la lista correspondiente\n                            qvalue.append(qcurr)\n                            # a\u00f1ado una lista vac\u00eda a E, S(Q,E) y err\n                            energy.append([])\n                            scatInt.append([])\n                            err.append([])\n                            numq = numq + 1  # Sumo uno al contador de Q\n                        # Si hay elementos y no empiezan por #, son los datos\n                        if (elements[0] != \"#\"):\n                            # A\u00f1ado los valores a la lista correspondiente\n                            energy[numq - 1].append(float(elements[0]))\n                            scatInt[numq - 1].append(float(elements[1]))\n                            err[numq - 1].append(float(elements[2]))\n                self.close_iFile(iFile)\n        return qvalue, energy, scatInt, err\n\n    def leer_de_FOCUS(self, iFile: _io.TextIOWrapper, qvalue: list[float],\n                      energy: list[list[float]], scatInt: list[list[float]],\n                      err: list[list[float]]) -&gt; tuple:\n        \"\"\"Parse the FOCUS data files.\n\n        Parameters\n        ----------\n        iFile: _io.TextIOWrapper\n            the object with the input file open\n        qvalue: list[float]\n            the array with the Q values\n        energy: list[list[float]]\n            the array with the arays of measured energies,\n            for earch Q\n        scatInt: list[list[float]]\n            the array with the arays of measured intensities,\n            for earch Q\n        err: list[list[float]]\n            the array with the arays of measured errors,\n            for earch Q\n\n        Returns\n        -------\n        A tuple with the values:\n        qvalue: list[float]\n        energy: list[list[float]]\n        scatInt: list[list[float]]\n        err: list[list[float]]\n\n        Other parameters\n        ----------------\n        line: str\n            to read de file line by line\n        elements: list[str]\n            to save all the elements of a line in a list\n        numq: int\n            to Q iterator (contador de Q, para cambiar de Q)\n        \"\"\"\n        line: str\n        elements: list[str]\n        numq: int\n        numq = 0  # Pongo el contador de Q a cero\n\n        for line in iFile.readlines():\n            elements = line.split()  # Divido la l\u00ednea en elementos\n            if (len(elements) != 0):  # La l\u00ednea le\u00edda no est\u00e1 vac\u00eda\n                # Para FOCUS la Q est\u00e1 en la l\u00ednea que empieza as\u00ed\n                if (elements[0] == \"#Group\" and elements[1] == \"Value:\"):\n                    # a\u00f1ado la Q a la lista correspondiente\n                    qvalue.append(float(elements[2]))\n                    # a\u00f1ado una lista vac\u00eda a E, S(Q,E) y err\n                    energy.append([])\n                    scatInt.append([])\n                    err.append([])\n                    numq = numq + 1  # Sumo uno al contador de Q\n                # Si hay elementos y no empiezan por #, son los datos\n                if (elements[0][0] != \"#\"):\n                    # A\u00f1ado los valores a la lista correspondiente\n                    energy[numq - 1].append(float(elements[0]))\n                    scatInt[numq - 1].append(float(elements[1]))\n                    err[numq - 1].append(float(elements[2]))\n        return qvalue, energy, scatInt, err\n\n    def read_from_ifile(self, iFile: _io.TextIOWrapper,\n                        instrument: str) -&gt; tuple:\n        \"\"\"Read from input files and saves the data in lists.\n\n        Calls a diferent parsing function depending on the input\n        instrument. **This fuction does not work with LET data.**\n\n        Parameters\n        ----------\n        iFile: _io.TextIOWrapper\n            object with the open input file\n        instrument: str\n            name of the instrument where the data was recorded\n\n        Returns\n        -------\n        A tuple with the values:\n        qvalue: list[float]\n        energy: list[list[float]]\n        scatInt: list[list[float]]\n        err: list[list[float]]\n\n        Other parameters\n        ----------------\n        qvalue: list[float]\n            the array with the Q values\n        energy: list[list[float]]\n            the array with the arays of measured energies,\n            for earch Q\n        scatInt: list[list[float]]\n            the array with the arays of measured intensities,\n            for earch Q\n        err: list[list[float]]\n            the array with the arays of measured errors,\n            for earch Q\n\n        See Also\n        --------\n        leer_de_IN5\n        leer_de_IN16B\n        leer_de_FOCUS\n        \"\"\"\n        qvalue: list[float]  # Para guardar los valores de Q\n        energy: list[list[float]]  # Para guardar la energ\u00eda dispersada\n        scatInt: list[list[float]]  # Para guardar S(Q,E)\n        err: list[list[float]]  # Para guardar el error experimental en S(Q,E)\n\n        # Inicializo las variables a listas vac\u00edas\n        qvalue = []\n        energy = []\n        scatInt = []\n        err = []\n\n        match instrument:\n            case \"IN5\":\n                qvalue, energy, scatInt, err = self.leer_de_IN5(\n                    iFile, qvalue, energy, scatInt, err)\n            case \"IN16B\":\n                qvalue, energy, scatInt, err = self.leer_de_IN16B(\n                    iFile, qvalue, energy, scatInt, err)\n            case \"FOCUS\":\n                qvalue, energy, scatInt, err = self.leer_de_FOCUS(\n                    iFile, qvalue, energy, scatInt, err)\n\n        return qvalue, energy, scatInt, err\n\n    def data_to_pandas_df(self, fileName: str, qvalue: list[float],\n                          energy: list[list[float]],\n                          scatInt: list[list[float]],\n                          err: list[list[float]]) -&gt; pd.DataFrame:\n        \"\"\"Save S(Q, E) data in a pandas DataFrame.\n\n        Parameters\n        ----------\n        fileName: str\n            the name to the input file, to asing it to the\n            intensity column\n        qvalue: list[float]\n            the array with the Q values\n        energy: list[list[float]]\n            the array with the array of energies for each Q\n        scatInt: list[list[float]]\n            the array with the arrays of intensities for each Q\n        err: list[list[float]])\n            the array with the arrays of errors in the intensity,\n            for each Q\n\n        Returns\n        -------\n        dfS: pd.DataFrame\n            DataFrame to save S(Q, E)\n\n        Other parameters\n        ----------------\n        energyS: pd.Series\n            a series to save the energy array for a Q, to concatenate\n            to dfS\n        scatIntS: pd.Series\n            a series to save the scattered intensity array for a Q,\n            to concatenate to dfS\n        errS: pd.Series\n            a series to save the measured error array for a Q, to\n            concatenate to dfS\n        i: int\n            iterator\n        q: float\n            iterator, to go over qvalue\n        scatIntLabel: str\n            to write the intensity column label\n        qstr: str\n            to write the intensity column label\n\n        See Also\n        --------\n        pandas.DataFrame.concat\n        pandas.Series.replace\n        \"\"\"\n        dfS: pd.DataFrame\n        dfS = pd.DataFrame()\n        # declaro estas series porque para que las columnas tengan el\n        # mismo nombre tengo que usar concat\n        energyS: pd.Series\n        scatIntS: pd.Series\n        errS: pd.Series\n\n        i: int\n        q: float\n        scatIntLabel: str\n        qstr: str\n\n        for i, q in enumerate(qvalue):\n            energyS = pd.Series(energy[i], name=\"E (meV)\")\n            # redondeo el valor de Q a 2 decimales\n            qstr = \"_\" + str(round(qvalue[i], 2)) + \"A-1\"\n            scatIntLabel = os.path.basename(fileName)[:-4] + qstr\n            scatIntS = pd.Series(scatInt[i], name=scatIntLabel)\n            errS = pd.Series(err[i], name=\"err\")\n            # En IN5 a veces hay valores del error &lt; 0. Los convierto a 0\n            errS = errS.replace(-1, 0)\n            dfS = pd.concat([dfS, energyS, scatIntS, errS], axis=1, names=[\n                            energyS.name, scatIntS.name, errS.name])\n\n        return dfS\n\n    def chi_from_S(self, temp: float, qvalue: list[float],\n                   dfS: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"Calculate the susceptibility.\n\n        Calculate the corresponding susceptibility of a given\n        scattered intensity S(Q, E) pandas.DataFrame. For each\n        Q value it saves E+, Chi+, E-, Chi-\n\n        Parameters\n        ----------\n        temp: float\n            the temperature at which the data was recorded\n        qvalue: list[float]\n            the array with the Q values\n        dfS: pd.DataFrame\n            the pandas.DataFrame with S(Q, E)\n\n        Returns\n        -------\n        dfchiSorted: pandas.DataFrame\n\n        Other parameters\n        ----------------\n        energyM: pd.Series\n            to save the energies E &lt; 0\n        energyP: pd.Series\n            to save the energies E &gt; 0\n        chiSM: pd.Series\n            to save the calculated susceptibilities for E&lt;0\n        chiSP: pd.Series\n            to save the calculated susceptibilities for E&gt;0\n        kb: float  # Boltzmann constant: 8.617333262 x 10-5 eV K-1\n        factSusS: pd.Series\n            to save the factor\n        dfchiM: pd.DataFrame\n            to save (E, Chi) for E&lt;0, because once taken the absolute\n            value, they need to be sorted in ascending order\n        dfchiSorted: pd.DataFrame\n            to save the susceptivilities\n        \"\"\"\n        # Quiero probar a guardar la susceptibilidad en E+ Chi+ E- Chi-,\n        # para cada Q.\n        energyM: pd.Series\n        energyP: pd.Series\n        chiSM: pd.Series\n        chiSP: pd.Series\n        kb: float\n        kb = 8.6173332e-5  # eV K-1\n        factSusS: pd.Series\n        dfchiM: pd.DataFrame\n        dfchiSorted: pd.DataFrame\n        dfchiSorted = pd.DataFrame()\n\n        for i, q in enumerate(qvalue):\n            # Guardo las E&lt;0 para una Q\n            energyM = dfS[dfS.iloc[:, 3 * i] &lt; 0].iloc[:, 3 * i]\n            energyM.name = 'E- (meV)'\n            factSusS = pd.Series(np.pi * (np.exp(\n                energyM.abs() / kb / 1000 / temp) - 1))\n            chiSM = factSusS * dfS[dfS.iloc[:, 3 * i] &lt; 0].iloc[:, 3 * i + 1]\n            chiSM.name = dfS.iloc[:, 3 * i + 1].name\n            energyM = energyM.abs()\n            dfchiM = pd.concat([energyM, chiSM], axis=1)\n            dfchiM.sort_values('E- (meV)', ascending=True, inplace=True)\n            # dfchiM.sort_values(energyM.name, ascending=True, inplace=True)\n            dfchiM.reset_index(drop=True, inplace=True)\n\n            # Guardo las E&gt;0 para una Q\n            energyP = dfS[dfS.iloc[:, 3 * i] &gt; 0].iloc[:, 3 * i]\n            energyP.name = 'E+ (meV)'\n            factSusS = pd.Series(np.pi * (1 - np.exp(\n                - energyP / kb / 1000 / temp)))\n            chiSP = factSusS * dfS[dfS.iloc[:, 3 * i] &gt; 0].iloc[:, 3 * i + 1]\n            chiSP.name = dfS.iloc[:, 3 * i + 1].name\n            dfchiP = pd.concat([energyP, chiSP], axis=1)\n            dfchiP.reset_index(drop=True, inplace=True)\n\n            dfchiSorted = pd.concat([dfchiSorted, dfchiM, dfchiP], axis=1)\n            # Borro los data frames antes de que cambie de Q\n            del dfchiM, dfchiP\n\n        return dfchiSorted\n\n    def save_data_to_csv(self, oFileName: str, dfS: pd.DataFrame) -&gt; bool:\n        \"\"\"Export S(Q, E) pandas.DataFrame to csv.\n\n        Saves the data in the scattered intensity S(Q, E)\n        pandas.DataFrame to a csv file. When exporting the\n        DataFrame, I remove ALL the rows only ifthere are NAN\n        values in ALL the I and err columns (for all the Q values).\n\n        Parameters\n        ----------\n        oFileName: str\n\n        dfS: pd.DataFrame\n            the data to be exported to a csv\n\n        Other parameters\n        ----------------\n        thresholdVal: int\n            Require that many non-NA values to keep the rows\n            &gt;Keep only the rows with at least 'thres' non-NA values.\n        \"\"\"\n        thresholdVal: int\n        # Todas las E son no-NAN. Si hay una columna m\u00e1s con no-NAN, NO\n        # se hace drop.\n        thresholdVal = int(len(dfS.columns) / 3 + 1)\n        dfS.dropna(axis=0, thresh=thresholdVal, inplace=True)\n        dfS.to_csv(oFileName, sep='\\t', index=False)\n\n        return True\n\n    def save_chi_data_to_csv(self, oFileName: str,\n                             dfchiSorted: pd.DataFrame) -&gt; bool:\n        \"\"\"Export Chi(Q, E) pandas.DataFrame to csv.\n\n        Saves the susceptivility data in the Chi(Q, E) pandas.DataFrame\n        to a csv file.When exporting the DataFrame, I remove ALL the rows\n        only if there are NAN values in ALL the I and err columns (for\n        all the Q values).\n\n        Parameters\n        ----------\n        oFileName: str\n\n        dfchiSorted: pd.DataFrame\n            the data to be exported to a csv\n\n        Other parameters\n        ----------------\n        thresholdVal: int\n            Require that many non-NA values to keep the rows\n            &gt;Keep only the rows with at least 'thres' non-NA values.\n        \"\"\"\n        thresholdVal: int\n        # En este caso, como la E no es simetrica respecto a cero,\n        # seguro que solo tengo valores no-NAN para todos las filas\n        # de las columnas E-. Hay un rango de filas para las que no\n        # tengo valores de E+, y por lo tanto son NAN.\n        # Si hay una columna m\u00e1s con no-NAN, no se hace drop\n        thresholdVal = int(len(dfchiSorted.columns) / 4 + 1)\n        dfchiSorted.dropna(thresh=thresholdVal, inplace=True)\n        dfchiSorted.to_csv(oFileName.replace('.csv', '_Chi.csv'), sep='\\t',\n                           index=False)\n\n        return True\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def __init__(self):\n    \"\"\"Class constructor.\"\"\"\n    print('FuncionesLeer constructor')\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.fileNameDropLET","title":"<code>fileNameDropLET(iFileName)</code>","text":"<p>Trim LET files names.</p> <p>Trims the filenames of the LET input file to find all the files begining with the same characters, belonging to the same measurement.</p> <p>Parameters:</p> Name Type Description Default <code>iFileName</code> <code>str</code> <p>the filename, icluding the path</p> required <p>Returns:</p> Name Type Description <code>fileName</code> <code>str</code> <p>the filename, excluding the path</p> <p>Other Parameters:</p> Name Type Description <code>firstParethesisPos</code> <p>the position in fileName of the first parenthesis</p> <code>charDrop</code> <p>the number of characters (at the endo of the filename) to delete</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def fileNameDropLET(self, iFileName: str) -&gt; str:\n    \"\"\"Trim LET files names.\n\n    Trims the filenames of the LET input file to find all the\n    files begining with the same characters, belonging to the\n    same measurement.\n\n    Parameters\n    ----------\n    iFileName:\n        the filename, icluding the path\n\n    Returns\n    -------\n    fileName: str\n        the filename, excluding the path\n\n    Other parameters\n    ---------\n    firstParethesisPos: int\n        the position in fileName of the first parenthesis\n    charDrop: int\n        the number of characters (at the endo of the filename)\n        to delete\n    \"\"\"\n    fileName: str\n    fileName = os.path.basename(iFileName)  # quita la ruta (path)\n    firstParethesisPos: int\n    # busco la primera aparici\u00f3n de el par\u00e9ntesis\n    firstParethesisPos = fileName.index('(')\n    charDrop: int\n    # calculo el n\u00famero de caracteres que quiero eliminar\n    charDrop = len(fileName) - firstParethesisPos\n    fileName = fileName[:-charDrop]\n    return fileName\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.check_path","title":"<code>check_path(path)</code>","text":"<p>Check if the path exist.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the input path</p> required <p>Raises:</p> Type Description <code>IOError</code> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def check_path(self, path: str) -&gt; bool:\n    \"\"\"Check if the path exist.\n\n    Parameters\n    ----------\n    path: str\n        the input path\n\n    Raises\n    ------\n    IOError\n    \"\"\"\n    if not os.path.exists(os.path.dirname(path)):\n        raise IOError(2, 'Path does not exist. ')\n    else:\n        return True\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.open_iFile","title":"<code>open_iFile(fileName)</code>","text":"<p>Open the data file.</p> <p>Parameters:</p> Name Type Description Default <code>fileName</code> <code>str</code> <p>the data file to be open, with path included</p> required <p>Returns:</p> Name Type Description <code>iFile</code> <code>TextIOWrapper</code> <p>the object to which the open file is assigned</p> <p>Raises:</p> Type Description <code>err: IOError</code> <p>the IOError to save the error</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def open_iFile(self, fileName: str) -&gt; _io.TextIOWrapper:\n    \"\"\"Open the data file.\n\n    Parameters\n    ----------\n    fileName: str\n        the data file to be open, with path included\n\n    Returns\n    -------\n    iFile: _io.TextIOWrapper\n        the object to which the open file is assigned\n\n    Raises\n    ------\n    err: IOError\n        the IOError to save the error\n    \"\"\"\n    # msg: str\n    iFile: _io.TextIOWrapper\n    try:\n        iFile = open(fileName, \"r\")  # abro el input file\n    except IOError:  # as err:\n        # msg = str(err.strerror)\n        raise OSError(2, 'Input file does not exist. ')\n        # return msg\n    else:\n        return iFile\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.close_iFile","title":"<code>close_iFile(iFile)</code>","text":"<p>Close the data file.</p> <p>Parameters:</p> Name Type Description Default <code>iFile</code> <code>TextIOWrapper</code> <p>the input object of the opened data file</p> required Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def close_iFile(self, iFile: _io.TextIOWrapper) -&gt; bool:\n    \"\"\"Close the data file.\n\n    Parameters\n    ----------\n    iFile: _io.TextIOWrapper\n        the input object of the opened data file\n    \"\"\"\n    iFile.close()  # Cuando acabo de leer el fichero, lo cierro\n    if iFile.closed is False:\n        print(\"Error closing file!\")\n        return False\n    else:\n        print(\"File closed!\")\n        return True\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.leer_de_IN5","title":"<code>leer_de_IN5(iFile, qvalue, energy, scatInt, err)</code>","text":"<p>Parse the IN5 data files.</p> <p>Parameters:</p> Name Type Description Default <code>iFile</code> <code>TextIOWrapper</code> <p>the objecto with the input file open</p> required <code>qvalue</code> <code>list[float]</code> <p>the array with the Q values</p> required <code>energy</code> <code>list[list[float]]</code> <p>the array with the arays of measured energies, for earch Q</p> required <code>scatInt</code> <code>list[list[float]]</code> <p>the array with the arays of measured intensities, for earch Q</p> required <code>err</code> <code>list[list[float]]</code> <p>the array with the arays of measured errors, for earch Q</p> required <p>Returns:</p> Name Type Description <code>A tuple with the values:</code> <code>qvalue</code> <code>list[float]</code> <code>energy</code> <code>list[list[float]]</code> <code>scatInt</code> <code>list[list[float]]</code> <code>err</code> <code>list[list[float]]</code> <p>Other Parameters:</p> Name Type Description <code>line</code> <p>to read de file line by line</p> <code>elements</code> <p>to save all the elements of a line in a list</p> <code>numq</code> <p>to Q iterator (contador de Q, para cambiar de Q)</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def leer_de_IN5(self, iFile: _io.TextIOWrapper, qvalue: list[float],\n                energy: list[list[float]], scatInt: list[list[float]],\n                err: list[list[float]]) -&gt; tuple:\n    \"\"\"Parse the IN5 data files.\n\n    Parameters\n    ----------\n    iFile: _io.TextIOWrapper\n        the objecto with the input file open\n    qvalue: list[float]\n        the array with the Q values\n    energy: list[list[float]]\n        the array with the arays of measured energies,\n        for earch Q\n    scatInt: list[list[float]]\n        the array with the arays of measured intensities,\n        for earch Q\n    err: list[list[float]]\n        the array with the arays of measured errors,\n        for earch Q\n\n    Returns\n    -------\n    A tuple with the values:\n    qvalue: list[float]\n    energy: list[list[float]]\n    scatInt: list[list[float]]\n    err: list[list[float]]\n\n    Other parameters\n    ----------------\n    line: str\n        to read de file line by line\n    elements: list[str]\n        to save all the elements of a line in a list\n    numq: int\n        to Q iterator (contador de Q, para cambiar de Q)\n    \"\"\"\n    line: str\n    elements: list[str]\n    numq: int\n    numq = 0  # Pongo el contador de Q a cero\n\n    for line in iFile.readlines():\n        elements = line.split()  # Divido la l\u00ednea en elementos\n        if (len(elements) != 0):  # la l\u00ednea le\u00edda no est\u00e1 vac\u00eda\n            # Para IN5, si son 6, el primer elemento es la Q\n            if (len(elements) == 6):\n                # a\u00f1ado la Q a la lista correspondiente\n                qvalue.append(float(elements[0]))\n                # a\u00f1ado una lista vac\u00eda a E, S(Q,E) y err\n                energy.append([])\n                scatInt.append([])\n                err.append([])\n                numq = numq + 1  # Sumo uno al contador de Q\n            # Si tengo 3 elementos en la l\u00ednea, son E, S(Q, E) y err\n            if (len(elements) == 3):\n                # hay una linea chunga que no s\u00e9 que es y empieza por 0\n                # la descarto\n                if (float(elements[0]) != 0):\n                    # A\u00f1ado los valores a las listas correspondientes\n                    energy[numq - 1].append(float(elements[0]))\n                    scatInt[numq - 1].append(float(elements[1]))\n                    err[numq - 1].append(float(elements[2]))\n    return qvalue, energy, scatInt, err\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.leer_de_IN16B","title":"<code>leer_de_IN16B(iFile, qvalue, energy, scatInt, err)</code>","text":"<p>Parse the IN16B data files.</p> <p>Parameters:</p> Name Type Description Default <code>iFile</code> <code>TextIOWrapper</code> <p>the object with the input file open</p> required <code>qvalue</code> <code>list[float]</code> <p>the array with the Q values</p> required <code>energy</code> <code>list[list[float]]</code> <p>the array with the arays of measured energies, for earch Q</p> required <code>scatInt</code> <code>list[list[float]]</code> <p>the array with the arays of measured intensities, for earch Q</p> required <code>err</code> <code>list[list[float]]</code> <p>the array with the arays of measured errors, for earch Q</p> required <p>Returns:</p> Name Type Description <code>A tuple with the values:</code> <code>qvalue</code> <code>list[float]</code> <code>energy</code> <code>list[list[float]]</code> <code>scatInt</code> <code>list[list[float]]</code> <code>err</code> <code>list[list[float]]</code> <p>Other Parameters:</p> Name Type Description <code>line</code> <p>to read de file line by line</p> <code>elements</code> <p>to save all the elements of a line in a list</p> <code>numq</code> <p>to Q iterator (contador de Q, para cambiar de Q)</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def leer_de_IN16B(self, iFile: _io.TextIOWrapper, qvalue: list[float],\n                  energy: list[list[float]], scatInt: list[list[float]],\n                  err: list[list[float]]) -&gt; tuple:\n    \"\"\"Parse the IN16B data files.\n\n    Parameters\n    ----------\n    iFile: _io.TextIOWrapper\n        the object with the input file open\n    qvalue: list[float]\n        the array with the Q values\n    energy: list[list[float]]\n        the array with the arays of measured energies,\n        for earch Q\n    scatInt: list[list[float]]\n        the array with the arays of measured intensities,\n        for earch Q\n    err: list[list[float]]\n        the array with the arays of measured errors,\n        for earch Q\n\n    Returns\n    -------\n    A tuple with the values:\n    qvalue: list[float]\n    energy: list[list[float]]\n    scatInt: list[list[float]]\n    err: list[list[float]]\n\n    Other parameters\n    ----------------\n    line: str\n        to read de file line by line\n    elements: list[str]\n        to save all the elements of a line in a list\n    numq: int\n        to Q iterator (contador de Q, para cambiar de Q)\n    \"\"\"\n    line: str\n    elements: list[str]\n    numq: int\n    numq = 0  # Pongo el contador de Q a cero\n\n    for line in iFile.readlines():\n        elements = line.split()  # Divido la l\u00ednea en elementos\n        if (len(elements) != 0):  # la l\u00ednea le\u00edda no est\u00e1 vac\u00eda\n            # Para IN16B, busco la Q\n            if (elements[0] == \"#\" and elements[1] == \"q(Angstrom^-1)\"):\n                # a\u00f1ado la Q a la lista correspondiente\n                qvalue.append(float(elements[3]))\n                # a\u00f1ado una lista vac\u00eda a E, S(Q,E) y err\n                energy.append([])\n                scatInt.append([])\n                err.append([])\n                numq = numq + 1  # Sumo uno al contador de Q\n            # Si hay elementos y no empiezan por #, son los datos\n            if (elements[0] != \"#\"):\n                # A\u00f1ado los valores a la lista correspondiente\n                energy[numq - 1].append(float(elements[0]))\n                scatInt[numq - 1].append(float(elements[1]))\n                err[numq - 1].append(float(elements[2]))\n    return qvalue, energy, scatInt, err\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.leer_de_LET","title":"<code>leer_de_LET(iFileName)</code>","text":"<p>Parse the LET data files.</p> <p>Parameters:</p> Name Type Description Default <code>iFileName</code> <code>str</code> <p>the input filename, with path</p> required <p>Returns:</p> Name Type Description <code>A tuple with the values:</code> <code>qvalue</code> <code>list[float]</code> <code>energy</code> <code>list[list[float]]</code> <code>scatInt</code> <code>list[list[float]]</code> <code>err</code> <code>list[list[float]]</code> <p>Other Parameters:</p> Name Type Description <code>qvalue</code> <p>the array with the Q values</p> <code>energy</code> <p>the array with the arays of measured energies, for earch Q</p> <code>scatInt</code> <p>the array with the arays of measured intensities, for earch Q</p> <code>err</code> <p>the array with the arays of measured errors, for earch Q</p> <code>line</code> <p>to read de file line by line</p> <code>elements</code> <p>to save all the elements of a line in a list</p> <code>qlist</code> <p>to save the string of the line where the Q interval is</p> <code>qmin</code> <p>the minimum Q in the Q interval</p> <code>qmax</code> <p>the maximum Q in the Q interval</p> <code>qcurr</code> <p>the Q of the currently reading input file</p> <code>numq</code> <p>to Q iterator (contador de Q, para cambiar de Q)</p> <code>filenames</code> <p>list with al the files in the folder</p> <code>dirs</code> <p>list with the subdirectories in the folder</p> <code>root</code> <code>f</code> <code>files</code> <p>the array where I save the file names that I want to read from</p> <code>path</code> <p>the path where the files are</p> <code>iFile</code> <p>the object with the input file open</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def leer_de_LET(self, iFileName: str) -&gt; tuple:\n    \"\"\"Parse the LET data files.\n\n    Parameters\n    ----------\n    iFileName: str\n        the input filename, with path\n\n    Returns\n    -------\n    A tuple with the values:\n    qvalue: list[float]\n    energy: list[list[float]]\n    scatInt: list[list[float]]\n    err: list[list[float]]\n\n    Other parameters\n    ----------------\n    qvalue: list[float]\n        the array with the Q values\n    energy: list[list[float]]\n        the array with the arays of measured energies,\n        for earch Q\n    scatInt: list[list[float]]\n        the array with the arays of measured intensities,\n        for earch Q\n    err: list[list[float]]\n        the array with the arays of measured errors,\n        for earch Q\n    line: str\n        to read de file line by line\n    elements: list[str]\n        to save all the elements of a line in a list\n    qlist: list[str]\n        to save the string of the line where the Q interval is\n    qmin: float\n        the minimum Q in the Q interval\n    qmax: float\n        the maximum Q in the Q interval\n    qcurr: float\n        the Q of the currently reading input file\n    numq: int\n        to Q iterator (contador de Q, para cambiar de Q)\n    filenames: list[str]\n        list with al the files in the folder\n    dirs: list[str]\n        list with the subdirectories in the folder\n    root: str\n        # me imagino que el path?\n    f: str\n    files: list[str]\n        the array where I save the file names that I want to read from\n    path: str\n        the path where the files are\n    iFile: _io.TextIOWrapper\n        the object with the input file open\n    \"\"\"\n    qvalue: list[float]\n    energy: list[list[float]]\n    scatInt: list[list[float]]\n    err: list[list[float]]\n    qvalue = []\n    energy = []\n    scatInt = []\n    err = []\n\n    line: str\n    elements: list[str]\n    qlist: list[str]\n    qmin: float  # la Q minima del intervalo\n    qmax: float  # la Q maxima del intervalo\n    qcurr: float  # la Q corespondiente al fichero q est\u00e1 leyendo\n    numq: int  # es el contador que voy a usar para cambiar de Q\n    numq = 0  # Pongo el contador de Q a cero\n    # Lo primero que tengo que hacer es buscar los ficheros que me\n    # interesan en la carpeta\n    filenames: list[str]  # la lista de todos los archivos en la carpeta\n    dirs: list[str]  # la lista de subdirectorios en la carpeta\n    root: str  # me imagino que el path?\n    f: str\n    files: list[str]\n    files = []\n    path: str\n    path = os.path.dirname(iFileName)\n    fileName = self.fileNameDropLET(iFileName)\n    for (root, dirs, filenames) in os.walk(path):\n        for f in filenames:\n            if fileName in f and '.txt' in f:\n                files.append(f)\n\n    iFile: _io.TextIOWrapper\n    for f in files:\n        try:\n            iFile = self.open_iFile(path + '/' + f)\n        except IOError:  # as error:\n            pass\n            # pongo algo m\u00e1s? qu\u00e9 quiero que haga si no consigue\n            # abrir un fichero?\n        else:\n            for line in iFile.readlines():\n                elements = line.split()  # Divido la l\u00ednea en elementos\n                if (len(elements) != 0):  # Si la l\u00ednea le\u00edda no est\u00e1 vac\u00eda\n                    # Para LET la Q est\u00e1 en la l\u00ednea que empieza as\u00ed:\n                    if (elements[1] == \"Integration\"):\n                        qlist = elements[3].split(\",\")\n                        qmin = float(qlist[1])\n                        qmax = float(qlist[2])\n                        qcurr = qmin + (qmax - qmin) / 2\n                        # a\u00f1ado la Q a la lista correspondiente\n                        qvalue.append(qcurr)\n                        # a\u00f1ado una lista vac\u00eda a E, S(Q,E) y err\n                        energy.append([])\n                        scatInt.append([])\n                        err.append([])\n                        numq = numq + 1  # Sumo uno al contador de Q\n                    # Si hay elementos y no empiezan por #, son los datos\n                    if (elements[0] != \"#\"):\n                        # A\u00f1ado los valores a la lista correspondiente\n                        energy[numq - 1].append(float(elements[0]))\n                        scatInt[numq - 1].append(float(elements[1]))\n                        err[numq - 1].append(float(elements[2]))\n            self.close_iFile(iFile)\n    return qvalue, energy, scatInt, err\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.leer_de_LET--me-imagino-que-el-path","title":"me imagino que el path?","text":""},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.leer_de_FOCUS","title":"<code>leer_de_FOCUS(iFile, qvalue, energy, scatInt, err)</code>","text":"<p>Parse the FOCUS data files.</p> <p>Parameters:</p> Name Type Description Default <code>iFile</code> <code>TextIOWrapper</code> <p>the object with the input file open</p> required <code>qvalue</code> <code>list[float]</code> <p>the array with the Q values</p> required <code>energy</code> <code>list[list[float]]</code> <p>the array with the arays of measured energies, for earch Q</p> required <code>scatInt</code> <code>list[list[float]]</code> <p>the array with the arays of measured intensities, for earch Q</p> required <code>err</code> <code>list[list[float]]</code> <p>the array with the arays of measured errors, for earch Q</p> required <p>Returns:</p> Name Type Description <code>A tuple with the values:</code> <code>qvalue</code> <code>list[float]</code> <code>energy</code> <code>list[list[float]]</code> <code>scatInt</code> <code>list[list[float]]</code> <code>err</code> <code>list[list[float]]</code> <p>Other Parameters:</p> Name Type Description <code>line</code> <p>to read de file line by line</p> <code>elements</code> <p>to save all the elements of a line in a list</p> <code>numq</code> <p>to Q iterator (contador de Q, para cambiar de Q)</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def leer_de_FOCUS(self, iFile: _io.TextIOWrapper, qvalue: list[float],\n                  energy: list[list[float]], scatInt: list[list[float]],\n                  err: list[list[float]]) -&gt; tuple:\n    \"\"\"Parse the FOCUS data files.\n\n    Parameters\n    ----------\n    iFile: _io.TextIOWrapper\n        the object with the input file open\n    qvalue: list[float]\n        the array with the Q values\n    energy: list[list[float]]\n        the array with the arays of measured energies,\n        for earch Q\n    scatInt: list[list[float]]\n        the array with the arays of measured intensities,\n        for earch Q\n    err: list[list[float]]\n        the array with the arays of measured errors,\n        for earch Q\n\n    Returns\n    -------\n    A tuple with the values:\n    qvalue: list[float]\n    energy: list[list[float]]\n    scatInt: list[list[float]]\n    err: list[list[float]]\n\n    Other parameters\n    ----------------\n    line: str\n        to read de file line by line\n    elements: list[str]\n        to save all the elements of a line in a list\n    numq: int\n        to Q iterator (contador de Q, para cambiar de Q)\n    \"\"\"\n    line: str\n    elements: list[str]\n    numq: int\n    numq = 0  # Pongo el contador de Q a cero\n\n    for line in iFile.readlines():\n        elements = line.split()  # Divido la l\u00ednea en elementos\n        if (len(elements) != 0):  # La l\u00ednea le\u00edda no est\u00e1 vac\u00eda\n            # Para FOCUS la Q est\u00e1 en la l\u00ednea que empieza as\u00ed\n            if (elements[0] == \"#Group\" and elements[1] == \"Value:\"):\n                # a\u00f1ado la Q a la lista correspondiente\n                qvalue.append(float(elements[2]))\n                # a\u00f1ado una lista vac\u00eda a E, S(Q,E) y err\n                energy.append([])\n                scatInt.append([])\n                err.append([])\n                numq = numq + 1  # Sumo uno al contador de Q\n            # Si hay elementos y no empiezan por #, son los datos\n            if (elements[0][0] != \"#\"):\n                # A\u00f1ado los valores a la lista correspondiente\n                energy[numq - 1].append(float(elements[0]))\n                scatInt[numq - 1].append(float(elements[1]))\n                err[numq - 1].append(float(elements[2]))\n    return qvalue, energy, scatInt, err\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.read_from_ifile","title":"<code>read_from_ifile(iFile, instrument)</code>","text":"<p>Read from input files and saves the data in lists.</p> <p>Calls a diferent parsing function depending on the input instrument. This fuction does not work with LET data.</p> <p>Parameters:</p> Name Type Description Default <code>iFile</code> <code>TextIOWrapper</code> <p>object with the open input file</p> required <code>instrument</code> <code>str</code> <p>name of the instrument where the data was recorded</p> required <p>Returns:</p> Name Type Description <code>A tuple with the values:</code> <code>qvalue</code> <code>list[float]</code> <code>energy</code> <code>list[list[float]]</code> <code>scatInt</code> <code>list[list[float]]</code> <code>err</code> <code>list[list[float]]</code> <p>Other Parameters:</p> Name Type Description <code>qvalue</code> <p>the array with the Q values</p> <code>energy</code> <p>the array with the arays of measured energies, for earch Q</p> <code>scatInt</code> <p>the array with the arays of measured intensities, for earch Q</p> <code>err</code> <p>the array with the arays of measured errors, for earch Q</p> See Also <p>leer_de_IN5 leer_de_IN16B leer_de_FOCUS</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def read_from_ifile(self, iFile: _io.TextIOWrapper,\n                    instrument: str) -&gt; tuple:\n    \"\"\"Read from input files and saves the data in lists.\n\n    Calls a diferent parsing function depending on the input\n    instrument. **This fuction does not work with LET data.**\n\n    Parameters\n    ----------\n    iFile: _io.TextIOWrapper\n        object with the open input file\n    instrument: str\n        name of the instrument where the data was recorded\n\n    Returns\n    -------\n    A tuple with the values:\n    qvalue: list[float]\n    energy: list[list[float]]\n    scatInt: list[list[float]]\n    err: list[list[float]]\n\n    Other parameters\n    ----------------\n    qvalue: list[float]\n        the array with the Q values\n    energy: list[list[float]]\n        the array with the arays of measured energies,\n        for earch Q\n    scatInt: list[list[float]]\n        the array with the arays of measured intensities,\n        for earch Q\n    err: list[list[float]]\n        the array with the arays of measured errors,\n        for earch Q\n\n    See Also\n    --------\n    leer_de_IN5\n    leer_de_IN16B\n    leer_de_FOCUS\n    \"\"\"\n    qvalue: list[float]  # Para guardar los valores de Q\n    energy: list[list[float]]  # Para guardar la energ\u00eda dispersada\n    scatInt: list[list[float]]  # Para guardar S(Q,E)\n    err: list[list[float]]  # Para guardar el error experimental en S(Q,E)\n\n    # Inicializo las variables a listas vac\u00edas\n    qvalue = []\n    energy = []\n    scatInt = []\n    err = []\n\n    match instrument:\n        case \"IN5\":\n            qvalue, energy, scatInt, err = self.leer_de_IN5(\n                iFile, qvalue, energy, scatInt, err)\n        case \"IN16B\":\n            qvalue, energy, scatInt, err = self.leer_de_IN16B(\n                iFile, qvalue, energy, scatInt, err)\n        case \"FOCUS\":\n            qvalue, energy, scatInt, err = self.leer_de_FOCUS(\n                iFile, qvalue, energy, scatInt, err)\n\n    return qvalue, energy, scatInt, err\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.data_to_pandas_df","title":"<code>data_to_pandas_df(fileName, qvalue, energy, scatInt, err)</code>","text":"<p>Save S(Q, E) data in a pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>fileName</code> <code>str</code> <p>the name to the input file, to asing it to the intensity column</p> required <code>qvalue</code> <code>list[float]</code> <p>the array with the Q values</p> required <code>energy</code> <code>list[list[float]]</code> <p>the array with the array of energies for each Q</p> required <code>scatInt</code> <code>list[list[float]]</code> <p>the array with the arrays of intensities for each Q</p> required <code>err</code> <code>list[list[float]]</code> <p>the array with the arrays of errors in the intensity, for each Q</p> required <p>Returns:</p> Name Type Description <code>dfS</code> <code>DataFrame</code> <p>DataFrame to save S(Q, E)</p> <p>Other Parameters:</p> Name Type Description <code>energyS</code> <p>a series to save the energy array for a Q, to concatenate to dfS</p> <code>scatIntS</code> <p>a series to save the scattered intensity array for a Q, to concatenate to dfS</p> <code>errS</code> <p>a series to save the measured error array for a Q, to concatenate to dfS</p> <code>i</code> <p>iterator</p> <code>q</code> <p>iterator, to go over qvalue</p> <code>scatIntLabel</code> <p>to write the intensity column label</p> <code>qstr</code> <p>to write the intensity column label</p> See Also <p>pandas.DataFrame.concat pandas.Series.replace</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def data_to_pandas_df(self, fileName: str, qvalue: list[float],\n                      energy: list[list[float]],\n                      scatInt: list[list[float]],\n                      err: list[list[float]]) -&gt; pd.DataFrame:\n    \"\"\"Save S(Q, E) data in a pandas DataFrame.\n\n    Parameters\n    ----------\n    fileName: str\n        the name to the input file, to asing it to the\n        intensity column\n    qvalue: list[float]\n        the array with the Q values\n    energy: list[list[float]]\n        the array with the array of energies for each Q\n    scatInt: list[list[float]]\n        the array with the arrays of intensities for each Q\n    err: list[list[float]])\n        the array with the arrays of errors in the intensity,\n        for each Q\n\n    Returns\n    -------\n    dfS: pd.DataFrame\n        DataFrame to save S(Q, E)\n\n    Other parameters\n    ----------------\n    energyS: pd.Series\n        a series to save the energy array for a Q, to concatenate\n        to dfS\n    scatIntS: pd.Series\n        a series to save the scattered intensity array for a Q,\n        to concatenate to dfS\n    errS: pd.Series\n        a series to save the measured error array for a Q, to\n        concatenate to dfS\n    i: int\n        iterator\n    q: float\n        iterator, to go over qvalue\n    scatIntLabel: str\n        to write the intensity column label\n    qstr: str\n        to write the intensity column label\n\n    See Also\n    --------\n    pandas.DataFrame.concat\n    pandas.Series.replace\n    \"\"\"\n    dfS: pd.DataFrame\n    dfS = pd.DataFrame()\n    # declaro estas series porque para que las columnas tengan el\n    # mismo nombre tengo que usar concat\n    energyS: pd.Series\n    scatIntS: pd.Series\n    errS: pd.Series\n\n    i: int\n    q: float\n    scatIntLabel: str\n    qstr: str\n\n    for i, q in enumerate(qvalue):\n        energyS = pd.Series(energy[i], name=\"E (meV)\")\n        # redondeo el valor de Q a 2 decimales\n        qstr = \"_\" + str(round(qvalue[i], 2)) + \"A-1\"\n        scatIntLabel = os.path.basename(fileName)[:-4] + qstr\n        scatIntS = pd.Series(scatInt[i], name=scatIntLabel)\n        errS = pd.Series(err[i], name=\"err\")\n        # En IN5 a veces hay valores del error &lt; 0. Los convierto a 0\n        errS = errS.replace(-1, 0)\n        dfS = pd.concat([dfS, energyS, scatIntS, errS], axis=1, names=[\n                        energyS.name, scatIntS.name, errS.name])\n\n    return dfS\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.chi_from_S","title":"<code>chi_from_S(temp, qvalue, dfS)</code>","text":"<p>Calculate the susceptibility.</p> <p>Calculate the corresponding susceptibility of a given scattered intensity S(Q, E) pandas.DataFrame. For each Q value it saves E+, Chi+, E-, Chi-</p> <p>Parameters:</p> Name Type Description Default <code>temp</code> <code>float</code> <p>the temperature at which the data was recorded</p> required <code>qvalue</code> <code>list[float]</code> <p>the array with the Q values</p> required <code>dfS</code> <code>DataFrame</code> <p>the pandas.DataFrame with S(Q, E)</p> required <p>Returns:</p> Name Type Description <code>dfchiSorted</code> <code>DataFrame</code> <p>Other Parameters:</p> Name Type Description <code>energyM</code> <p>to save the energies E &lt; 0</p> <code>energyP</code> <p>to save the energies E &gt; 0</p> <code>chiSM</code> <p>to save the calculated susceptibilities for E&lt;0</p> <code>chiSP</code> <p>to save the calculated susceptibilities for E&gt;0</p> <code>kb</code> <code>factSusS</code> <p>to save the factor</p> <code>dfchiM</code> <p>to save (E, Chi) for E&lt;0, because once taken the absolute value, they need to be sorted in ascending order</p> <code>dfchiSorted</code> <p>to save the susceptivilities</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def chi_from_S(self, temp: float, qvalue: list[float],\n               dfS: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"Calculate the susceptibility.\n\n    Calculate the corresponding susceptibility of a given\n    scattered intensity S(Q, E) pandas.DataFrame. For each\n    Q value it saves E+, Chi+, E-, Chi-\n\n    Parameters\n    ----------\n    temp: float\n        the temperature at which the data was recorded\n    qvalue: list[float]\n        the array with the Q values\n    dfS: pd.DataFrame\n        the pandas.DataFrame with S(Q, E)\n\n    Returns\n    -------\n    dfchiSorted: pandas.DataFrame\n\n    Other parameters\n    ----------------\n    energyM: pd.Series\n        to save the energies E &lt; 0\n    energyP: pd.Series\n        to save the energies E &gt; 0\n    chiSM: pd.Series\n        to save the calculated susceptibilities for E&lt;0\n    chiSP: pd.Series\n        to save the calculated susceptibilities for E&gt;0\n    kb: float  # Boltzmann constant: 8.617333262 x 10-5 eV K-1\n    factSusS: pd.Series\n        to save the factor\n    dfchiM: pd.DataFrame\n        to save (E, Chi) for E&lt;0, because once taken the absolute\n        value, they need to be sorted in ascending order\n    dfchiSorted: pd.DataFrame\n        to save the susceptivilities\n    \"\"\"\n    # Quiero probar a guardar la susceptibilidad en E+ Chi+ E- Chi-,\n    # para cada Q.\n    energyM: pd.Series\n    energyP: pd.Series\n    chiSM: pd.Series\n    chiSP: pd.Series\n    kb: float\n    kb = 8.6173332e-5  # eV K-1\n    factSusS: pd.Series\n    dfchiM: pd.DataFrame\n    dfchiSorted: pd.DataFrame\n    dfchiSorted = pd.DataFrame()\n\n    for i, q in enumerate(qvalue):\n        # Guardo las E&lt;0 para una Q\n        energyM = dfS[dfS.iloc[:, 3 * i] &lt; 0].iloc[:, 3 * i]\n        energyM.name = 'E- (meV)'\n        factSusS = pd.Series(np.pi * (np.exp(\n            energyM.abs() / kb / 1000 / temp) - 1))\n        chiSM = factSusS * dfS[dfS.iloc[:, 3 * i] &lt; 0].iloc[:, 3 * i + 1]\n        chiSM.name = dfS.iloc[:, 3 * i + 1].name\n        energyM = energyM.abs()\n        dfchiM = pd.concat([energyM, chiSM], axis=1)\n        dfchiM.sort_values('E- (meV)', ascending=True, inplace=True)\n        # dfchiM.sort_values(energyM.name, ascending=True, inplace=True)\n        dfchiM.reset_index(drop=True, inplace=True)\n\n        # Guardo las E&gt;0 para una Q\n        energyP = dfS[dfS.iloc[:, 3 * i] &gt; 0].iloc[:, 3 * i]\n        energyP.name = 'E+ (meV)'\n        factSusS = pd.Series(np.pi * (1 - np.exp(\n            - energyP / kb / 1000 / temp)))\n        chiSP = factSusS * dfS[dfS.iloc[:, 3 * i] &gt; 0].iloc[:, 3 * i + 1]\n        chiSP.name = dfS.iloc[:, 3 * i + 1].name\n        dfchiP = pd.concat([energyP, chiSP], axis=1)\n        dfchiP.reset_index(drop=True, inplace=True)\n\n        dfchiSorted = pd.concat([dfchiSorted, dfchiM, dfchiP], axis=1)\n        # Borro los data frames antes de que cambie de Q\n        del dfchiM, dfchiP\n\n    return dfchiSorted\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.save_data_to_csv","title":"<code>save_data_to_csv(oFileName, dfS)</code>","text":"<p>Export S(Q, E) pandas.DataFrame to csv.</p> <p>Saves the data in the scattered intensity S(Q, E) pandas.DataFrame to a csv file. When exporting the DataFrame, I remove ALL the rows only ifthere are NAN values in ALL the I and err columns (for all the Q values).</p> <p>Parameters:</p> Name Type Description Default <code>oFileName</code> <code>str</code> required <code>dfS</code> <code>DataFrame</code> <p>the data to be exported to a csv</p> required <p>Other Parameters:</p> Name Type Description <code>thresholdVal</code> <p>Require that many non-NA values to keep the rows</p> <p>Keep only the rows with at least 'thres' non-NA values.</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def save_data_to_csv(self, oFileName: str, dfS: pd.DataFrame) -&gt; bool:\n    \"\"\"Export S(Q, E) pandas.DataFrame to csv.\n\n    Saves the data in the scattered intensity S(Q, E)\n    pandas.DataFrame to a csv file. When exporting the\n    DataFrame, I remove ALL the rows only ifthere are NAN\n    values in ALL the I and err columns (for all the Q values).\n\n    Parameters\n    ----------\n    oFileName: str\n\n    dfS: pd.DataFrame\n        the data to be exported to a csv\n\n    Other parameters\n    ----------------\n    thresholdVal: int\n        Require that many non-NA values to keep the rows\n        &gt;Keep only the rows with at least 'thres' non-NA values.\n    \"\"\"\n    thresholdVal: int\n    # Todas las E son no-NAN. Si hay una columna m\u00e1s con no-NAN, NO\n    # se hace drop.\n    thresholdVal = int(len(dfS.columns) / 3 + 1)\n    dfS.dropna(axis=0, thresh=thresholdVal, inplace=True)\n    dfS.to_csv(oFileName, sep='\\t', index=False)\n\n    return True\n</code></pre>"},{"location":"ref-funcionesleer/#QENS_to_csv_pkg.FuncionesLeer.FuncionesLeer.save_chi_data_to_csv","title":"<code>save_chi_data_to_csv(oFileName, dfchiSorted)</code>","text":"<p>Export Chi(Q, E) pandas.DataFrame to csv.</p> <p>Saves the susceptivility data in the Chi(Q, E) pandas.DataFrame to a csv file.When exporting the DataFrame, I remove ALL the rows only if there are NAN values in ALL the I and err columns (for all the Q values).</p> <p>Parameters:</p> Name Type Description Default <code>oFileName</code> <code>str</code> required <code>dfchiSorted</code> <code>DataFrame</code> <p>the data to be exported to a csv</p> required <p>Other Parameters:</p> Name Type Description <code>thresholdVal</code> <p>Require that many non-NA values to keep the rows</p> <p>Keep only the rows with at least 'thres' non-NA values.</p> Source code in <code>QENS_to_csv_pkg\\FuncionesLeer.py</code> <pre><code>def save_chi_data_to_csv(self, oFileName: str,\n                         dfchiSorted: pd.DataFrame) -&gt; bool:\n    \"\"\"Export Chi(Q, E) pandas.DataFrame to csv.\n\n    Saves the susceptivility data in the Chi(Q, E) pandas.DataFrame\n    to a csv file.When exporting the DataFrame, I remove ALL the rows\n    only if there are NAN values in ALL the I and err columns (for\n    all the Q values).\n\n    Parameters\n    ----------\n    oFileName: str\n\n    dfchiSorted: pd.DataFrame\n        the data to be exported to a csv\n\n    Other parameters\n    ----------------\n    thresholdVal: int\n        Require that many non-NA values to keep the rows\n        &gt;Keep only the rows with at least 'thres' non-NA values.\n    \"\"\"\n    thresholdVal: int\n    # En este caso, como la E no es simetrica respecto a cero,\n    # seguro que solo tengo valores no-NAN para todos las filas\n    # de las columnas E-. Hay un rango de filas para las que no\n    # tengo valores de E+, y por lo tanto son NAN.\n    # Si hay una columna m\u00e1s con no-NAN, no se hace drop\n    thresholdVal = int(len(dfchiSorted.columns) / 4 + 1)\n    dfchiSorted.dropna(thresh=thresholdVal, inplace=True)\n    dfchiSorted.to_csv(oFileName.replace('.csv', '_Chi.csv'), sep='\\t',\n                       index=False)\n\n    return True\n</code></pre>"},{"location":"reference/","title":"Ref. QENS to csv App","text":"<p>App to sort QENS data.</p> <p>Filename: app_QENStoCSV_Dlg.py Author: Beatriz Robles Hern\u00e1ndez Date: 2025-03-10 Version: 1.0 Description:     This script runs an GUI app to read QENS data files recorded     in different facilities, organizes it as a matrix and export     it as a csv file. Also computes susceptibility if required.</p> <p>License: GLP Contact: broblesher@gmail.com Dependencies: os, sys, _io, pandas, FuncionesLeer, PyQt5, QENStoCSV_Dlg</p>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG","title":"<code>DLG</code>","text":"<p>               Bases: <code>QDialog</code>, <code>Ui_Dialog_QENStoCSV</code></p> <p>DLG window class.</p> <p>A class used to create the dialog window. Contains the methods to run the elements of the dlg.</p> <p>Attributes:</p> Name Type Description <code>_instrument</code> <code>str</code> <p>to save the instrument in which the data was recorded</p> <code>_rb_value</code> <p>to save the radiobutton state</p> <code>_iFileName</code> <code>str</code> <p>to save the input file name and path</p> <code>_oFileName</code> <code>str</code> <p>to save the output file name and path</p> <code>_defaultPath</code> <code>str</code> <p>to save the default path when initializing the app</p> <code>_susceptivility_checked</code> <code>bool</code> <p>to save the value of the susceptivility checkbox</p> <code>_temperature</code> <code>str</code> <p>to save the (str) value of the temperature introduced in the lineEdit</p> <code>_last_msg</code> <code>str</code> <p>to save the last message displayed in the log textBrowser</p> <code>_current_date</code> <code>str</code> <p>to save the current date and time when displaying a msg</p> <code>_funcionesLeer</code> <code>FuncionesLeer</code> <p>an instance to the class FuncionesLeer][QENS_to_csv_pkg.FuncionesLeer] to read and write from/to the input/output files</p> <p>Methods:</p> Name Description <code>set_iFile_DisplayText</code> <p>Sets the input display's text</p> <code>set_oFile_DisplayText</code> <p>Sets the output display's text</p> <code>display_iFile_Text</code> <p>Gets the input display's text</p> <code>display_oFile_Text</code> <p>Gets the output display's text</p> <code>open_iFileDialog</code> <p>Creates the browser dlg to select the input file</p> <code>open_oFileDialog</code> <p>Creates the browser dlg to select the output file</p> <code>display_temp_Text</code> <p>Gets the temperature display's text</p> <code>updateRadioSelection</code> <p>Checks the radio buttons</p> <code>updateCheckBoxState</code> <p>Saves the checkbox's value</p> <code>sortAndSave</code> <p>Sorts the input data in a matrix form and saves it as csv</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>class DLG(QDialog, Ui_Dialog_QENStoCSV):\n    \"\"\"DLG window class.\n\n    A class used to create the dialog window. Contains the methods\n    to run the elements of the dlg.\n\n    Attributes\n    ----------\n    _instrument: str\n        to save the instrument in which the data was recorded\n    _rb_value:\n        to save the radiobutton state\n    _iFileName: str\n        to save the input file name and path\n    _oFileName: str\n        to save the output file name and path\n    _defaultPath: str\n        to save the default path when initializing the app\n    _susceptivility_checked: bool\n        to save the value of the susceptivility checkbox\n    _temperature: str\n        to save the (str) value of the temperature introduced\n        in the lineEdit\n    _last_msg: str\n        to save the last message displayed in the log textBrowser\n    _current_date: str\n        to save the current date and time when displaying a msg\n    _funcionesLeer: FuncionesLeer\n        an instance to the class FuncionesLeer][QENS_to_csv_pkg.FuncionesLeer]\n        to read and write from/to the input/output files\n\n    Methods\n    -------\n    set_iFile_DisplayText(text)\n        Sets the input display's text\n    set_oFile_DisplayText(text)\n        Sets the output display's text\n    display_iFile_Text()\n        Gets the input display's text\n    display_oFile_Text()\n        Gets the output display's text\n    open_iFileDialog()\n        Creates the browser dlg to select the input file\n    open_oFileDialog()\n        Creates the browser dlg to select the output file\n    display_temp_Text()\n        Gets the temperature display's text\n    updateRadioSelection()\n        Checks the radio buttons\n    updateCheckBoxState()\n        Saves the checkbox's value\n    sortAndSave()\n        Sorts the input data in a matrix form\n        and saves it as csv\n    \"\"\"\n\n    def __init__(self, parent=None):\n        \"\"\"Class constructor.\n\n        Attributes\n        ----------\n        _intrument: str\n            the name of the instrument in which the data was recorded\n        _rb_value: str\n            the value of the radio button to select the intrument\n        _iFileName: str\n            the name of the input data file\n        _oFileName: str\n            the name of the output data file\n        _defaultPath: str\n            the default path in the browser.\n            It is set to \"./User/Documents\"\n        _susceptivility_checked: bool\n            the status of the check box that gives the option to save\n            the susceptivility\n        _temperature: str\n            the string value of the temperature introduced in the dlg\n        _last_msg: str\n            the last message shown in the log section\n        _current_date: str\n            the date shown in the last message in the log section\n        \"\"\"\n        super().__init__(parent)\n        self.setupUi(self)\n        print('Initialized')\n        self._instrument = ''\n        self._rb_value = 'unchecked'\n        self._iFileName = ''\n        self._oFileName = ''\n        self._defaultPath = os.path.expanduser('~')\n        # self._ifile_selected = False\n        # self._ofile_selected = False\n        self._susceptivility_checked = False\n        self._temperature = ''\n        self._last_msg = ''\n        self._current_date = ''\n        # self._error: IOError # se puede asignar a algo que no haya nada?\n\n        self._funcionesLeer = fl.FuncionesLeer()\n\n    def set_iFile_DisplayText(self, text: str):\n        \"\"\"Set the input display's text.\n\n        Set the input display's text, when selecting something from\n        the browser, for instance\n\n        Parameters\n        ----------\n        text: str\n            the text to be displayed\n        \"\"\"\n        self.lineEdit_iFile.setText(text)\n        self.lineEdit_iFile.setFocus()\n\n    def set_oFile_DisplayText(self, text: str):\n        \"\"\"Set the input display's text.\n\n        Set the output display's text, when selecting something from\n        the browser, for instance\n\n        Parameters\n        ----------\n        text: str\n            the text to be displayed\n        \"\"\"\n        self.lineEdit_oFile.setText(text)\n        self.lineEdit_oFile.setFocus()\n\n    def display_iFile_Text(self) -&gt; str:\n        \"\"\"Get the input display's text.\n\n        Returns\n        -------\n        lineEdit_iFile.text(): str\n            the text in the display\n        \"\"\"\n        return self.lineEdit_iFile.text()\n\n    def display_oFile_Text(self) -&gt; str:\n        \"\"\"Get the output display's text.\n\n        Returns\n        -------\n        lineEdit_oFile.text(): str\n            the text in the display\n        \"\"\"\n        return self.lineEdit_oFile.text()\n\n    def open_iFileDialog(self):\n        \"\"\"Create the browser dlg to select the input file.\"\"\"\n        ifile_dialog = QFileDialog(self)\n        ifile_dialog.setWindowTitle('Open Input File')\n        ifile_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptOpen)\n        self._iFileName = self.display_iFile_Text()\n        if self._iFileName == '':\n            ifile_dialog.setDirectory(self._defaultPath)\n        else:\n            try:\n                self._funcionesLeer.check_path(self._iFileName)\n            except IOError:  # as error:\n                ifile_dialog.setDirectory(self._defaultPath)\n            else:\n                ifile_dialog.setDirectory(self._iFileName)\n\n        ifile_dialog.setNameFilter('Text (*.inx *.dat *.txt)')\n        ifile_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)\n        ifile_dialog.setViewMode(QFileDialog.ViewMode.Detail)\n\n        if ifile_dialog.exec():\n            # As\u00ed se guarda el nombre del archivo y la ruta\n            self._iFileName = ifile_dialog.selectedFiles()\n            self.set_iFile_DisplayText(self._iFileName[0])\n\n    def display_temp_Text(self) -&gt; str:\n        \"\"\"Get the temperature display's text.\n\n        Returns\n        -------\n        lineEdit_Temp.text(): str\n            the text in the display\n\n        \"\"\"\n        return self.lineEdit_Temp.text()\n\n    def open_oFileDialog(self):\n        \"\"\"Create the browser dlg to select the output file.\"\"\"\n        ofile_dialog = QFileDialog(self)\n        ofile_dialog.setWindowTitle(\"Set Output File Name\")\n        ofile_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)\n        self._oFileName = self.display_oFile_Text()\n        if self._oFileName == '':\n            ofile_dialog.setDirectory(self._defaultPath)\n            try:\n                self._funcionesLeer.check_path(self._oFileName)\n            except IOError:  # as error:\n                ofile_dialog.setDirectory(self._defaultPath)\n            else:\n                ofile_dialog.setDirectory(self._oFileName)\n\n        ofile_dialog.setNameFilter(\"Text (*.csv)\")\n        ofile_dialog.setViewMode(QFileDialog.ViewMode.Detail)\n\n        if ofile_dialog.exec():\n            # As\u00ed se guarda e nombre del archivo y la ruta\n            self._oFileName = ofile_dialog.selectedFiles()\n            self.set_oFile_DisplayText(self._oFileName[0])\n\n    def updateRadioSelection(self) -&gt; bool:\n        \"\"\"Check the radio buttons.\"\"\"\n        # get the radio button the send the signal\n        rb = self.sender()\n        # check if the radio button is checked\n        if rb.isChecked():\n            self._rb_value = 'cheked'\n            self._instrument = rb.text()\n        return True\n\n    def updateCheckBoxState(self):\n        \"\"\"Save the checkbox's value.\n\n        Also enables/disables the temperature lineEdit.\n        \"\"\"\n        if self.checkBox_Susceptivility.isChecked() is True:\n            self.label_Temp.setDisabled(False)\n            self.lineEdit_Temp.setDisabled(False)\n            self.label_K.setDisabled(False)\n            self._susceptivility_checked = True\n        if self.checkBox_Susceptivility.isChecked() is False:\n            self.label_Temp.setDisabled(True)\n            self.lineEdit_Temp.setDisabled(True)\n            self.label_K.setDisabled(True)\n            self._susceptivility_checked = False\n\n    # Funci\u00f3n que se ejecuta cuando pulso save\n    def sortAndSave(self) -&gt; bool:\n        \"\"\"Sort input data and save as csv.\n\n        Check if all the conditions meet to sort and save the data,\n        and if so, proceeds.\n\n        Other parameters\n        ----------------\n        _iFileName: str\n            to save the input file name and path\n        _oFileName: str\n            to save the output file name and path\n        _current_date: str\n            to save the current date and time when displaying a msg\n        _last_msg: str\n            to save the last message displayed in the log textBrowser\n        qvalue: list[float]\n            to save the Q values\n        energy: list[list[float]]\n            to save the Energy array for each Q\n        scatInt: list[list[float]]\n            to save the scattered intensity for each Q\n        err: list[list[float]]\n            to save the measured error in the intensity for each Q\n        iFile: _io.TextIOWrapper\n            to save the opened input file\n        path: str\n            to save the path\n        dfS: pandas.DataFrame\n            to save the S(Q, E) in a matrix form\n        dfChiSorted: pandas.DataFrame\n            to save the Chi (Q, E) in a matrix from\n        temp: float\n            to save the numeric value of the temperature\n\n        Raises\n        ------\n        OSError\n            if the path or the file does not exist\n        \"\"\"\n        # Lo primero deber\u00eda comprobar que los valores de los edit de\n        # los files existen.\n        self._iFileName = self.display_iFile_Text()\n        self._oFileName = self.display_oFile_Text()\n\n        # Necesito comprobar que alg\u00fan radio button est\u00e1 seleccionado\n        if self._rb_value == 'unchecked':\n            self._current_date = QDateTime.currentDateTime().\\\n                toString('hh:mm:ss')\n            self._last_msg = self._current_date + ': Select instrument\\n'\n            self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n            self.textBrowser_log.insertPlainText(self._last_msg)\n            return False\n\n        try:\n            self._funcionesLeer.check_path(self._iFileName)\n        except IOError as error:\n            self._current_date = QDateTime.currentDateTime().\\\n                toString('hh:mm:ss')\n            self._last_msg = self._current_date + ': ' + \\\n                str(error.strerror) + 'Enter a valid input path\\n'\n            self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n            self.textBrowser_log.insertPlainText(self._last_msg)\n            return False\n        else:\n            # \"Declaro\" variables para guardar los datos\n            qvalue: list[float]\n            energy: list[list[float]]\n            scatInt: list[list[float]]\n            err: list[list[float]]\n\n            if (self._instrument != 'LET'):\n                iFile: _io.TextIOWrapper\n                # LLamo a la funci\u00f3n que abre el fichero con las medidas\n                try:\n                    iFile = self._funcionesLeer.open_iFile(self._iFileName)\n                except OSError as error:\n                    self._current_date = QDateTime.currentDateTime().\\\n                        toString('hh:mm:ss')\n                    self._last_msg = self._current_date + ': ' + \\\n                        str(error.strerror) + '\\n'\n                    self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                    self.textBrowser_log.insertPlainText(self._last_msg)\n                    return False\n                else:\n                    # Llamo a la funci\u00f3n que me guarda los datos en listas\n                    qvalue, energy, scatInt, err = self._funcionesLeer.\\\n                        read_from_ifile(iFile, self._instrument)\n                    # Y cierro el archivo de datos\n                    self._funcionesLeer.close_iFile(iFile)\n            else:\n                qvalue, energy, scatInt, err = self._funcionesLeer.\\\n                    leer_de_LET(self._iFileName)\n                # corto el nombre del archivo y lo junto con el path otra vez\n                # para poder nombrar las columnas en los data frames\n                path: str\n                path = os.path.dirname(self._iFileName)\n                self._iFileName = path + \\\n                    self._funcionesLeer.fileNameDropLET(self._iFileName)\n\n            # Defino el Data Frame para guardar S(Q,E)\n            dfS: pd.DataFrame\n            # Llamo a la funci\u00f3n que me guarda los datos en DataFrame de Pandas\n            dfS = self._funcionesLeer.data_to_pandas_df(\n                self._iFileName, qvalue, energy, scatInt, err)\n\n            # Por \u00faltimo, exporto S(Q,E) a  CSVs\n            try:\n                self._funcionesLeer.check_path(self._oFileName)\n            except IOError as error:\n                self._current_date = QDateTime.currentDateTime().\\\n                    toString('hh:mm:ss')\n                self._last_msg = self._current_date + ': ' + \\\n                    str(error.strerror) + 'Enter a valid output path\\n'\n                self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                self.textBrowser_log.insertPlainText(self._last_msg)\n                return False\n            else:\n                try:\n                    self._funcionesLeer.save_data_to_csv(self._oFileName, dfS)\n                except IOError:\n                    self._current_date = QDateTime.currentDateTime().\\\n                        toString('hh:mm:ss')\n                    self._last_msg = self._current_date + \\\n                        ': Error exporting data to CSV!\\n'\n                    self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                    self.textBrowser_log.insertPlainText(self._last_msg)\n                    return False\n                else:\n                    self._current_date = QDateTime.currentDateTime().\\\n                        toString('hh:mm:ss')\n                    self._last_msg = self._current_date + \\\n                        ': Data succesfully exported to CSV!\\n'\n                    self.textBrowser_log.insertPlainText(self._last_msg)\n\n            if self._susceptivility_checked is True:\n                # Guardo el valor de la temperatura\n                self._temperature = self.display_temp_Text()\n                temp: float\n                try:\n                    temp = float(self._temperature)\n                except ValueError:\n                    self._current_date = QDateTime.currentDateTime().\\\n                        toString('hh:mm:ss')\n                    self._last_msg = self._current_date + \\\n                        ': Enter a valid temperature\\n'\n                    self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                    self.textBrowser_log.insertPlainText(self._last_msg)\n                    return False\n\n                # Defino el DataFrame donde voy a guardar la susceptibilidad\n                dfChiSorted: pd.DataFrame\n                # Llamo a la funci\u00f3n que me calcula Chi a partir de E y S(Q,E)\n                # y me lo guarda en un DataFrame\n                dfChiSorted = self._funcionesLeer.chi_from_S(temp, qvalue, dfS)\n                # Por \u00faltimo, exporto Chi(Q,E) a  CSVs\n                try:\n                    self._funcionesLeer.check_path(self._oFileName)\n                except IOError as error:\n                    self._current_date = QDateTime.currentDateTime().\\\n                        toString('hh:mm:ss')\n                    self._last_msg = self._current_date + ': ' + \\\n                        str(error.strerror) + 'Enter a valid output path\\n'\n                    self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                    self.textBrowser_log.insertPlainText(self._last_msg)\n                    return False\n                else:\n                    try:\n                        self._funcionesLeer.save_chi_data_to_csv(\n                            self._oFileName, dfChiSorted)\n                    except IOError:\n                        self._current_date = QDateTime.currentDateTime().\\\n                            toString('hh:mm:ss')\n                        self._last_msg = self._current_date + \\\n                            ': Error exporting susceptivility data to CSV!\\n'\n                        self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                        self.textBrowser_log.insertPlainText(self._last_msg)\n                        return False\n                    else:\n                        self._current_date = QDateTime.currentDateTime().\\\n                            toString('hh:mm:ss')\n                        self._last_msg = self._current_date + \\\n                            ': Susceptivility data exported to CSV!\\n'\n                        self.textBrowser_log.insertPlainText(self._last_msg)\n        return True\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Attributes:</p> Name Type Description <code>_intrument</code> <code>str</code> <p>the name of the instrument in which the data was recorded</p> <code>_rb_value</code> <code>str</code> <p>the value of the radio button to select the intrument</p> <code>_iFileName</code> <code>str</code> <p>the name of the input data file</p> <code>_oFileName</code> <code>str</code> <p>the name of the output data file</p> <code>_defaultPath</code> <code>str</code> <p>the default path in the browser. It is set to \"./User/Documents\"</p> <code>_susceptivility_checked</code> <code>bool</code> <p>the status of the check box that gives the option to save the susceptivility</p> <code>_temperature</code> <code>str</code> <p>the string value of the temperature introduced in the dlg</p> <code>_last_msg</code> <code>str</code> <p>the last message shown in the log section</p> <code>_current_date</code> <code>str</code> <p>the date shown in the last message in the log section</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def __init__(self, parent=None):\n    \"\"\"Class constructor.\n\n    Attributes\n    ----------\n    _intrument: str\n        the name of the instrument in which the data was recorded\n    _rb_value: str\n        the value of the radio button to select the intrument\n    _iFileName: str\n        the name of the input data file\n    _oFileName: str\n        the name of the output data file\n    _defaultPath: str\n        the default path in the browser.\n        It is set to \"./User/Documents\"\n    _susceptivility_checked: bool\n        the status of the check box that gives the option to save\n        the susceptivility\n    _temperature: str\n        the string value of the temperature introduced in the dlg\n    _last_msg: str\n        the last message shown in the log section\n    _current_date: str\n        the date shown in the last message in the log section\n    \"\"\"\n    super().__init__(parent)\n    self.setupUi(self)\n    print('Initialized')\n    self._instrument = ''\n    self._rb_value = 'unchecked'\n    self._iFileName = ''\n    self._oFileName = ''\n    self._defaultPath = os.path.expanduser('~')\n    # self._ifile_selected = False\n    # self._ofile_selected = False\n    self._susceptivility_checked = False\n    self._temperature = ''\n    self._last_msg = ''\n    self._current_date = ''\n    # self._error: IOError # se puede asignar a algo que no haya nada?\n\n    self._funcionesLeer = fl.FuncionesLeer()\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.set_iFile_DisplayText","title":"<code>set_iFile_DisplayText(text)</code>","text":"<p>Set the input display's text.</p> <p>Set the input display's text, when selecting something from the browser, for instance</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the text to be displayed</p> required Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def set_iFile_DisplayText(self, text: str):\n    \"\"\"Set the input display's text.\n\n    Set the input display's text, when selecting something from\n    the browser, for instance\n\n    Parameters\n    ----------\n    text: str\n        the text to be displayed\n    \"\"\"\n    self.lineEdit_iFile.setText(text)\n    self.lineEdit_iFile.setFocus()\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.set_oFile_DisplayText","title":"<code>set_oFile_DisplayText(text)</code>","text":"<p>Set the input display's text.</p> <p>Set the output display's text, when selecting something from the browser, for instance</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>the text to be displayed</p> required Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def set_oFile_DisplayText(self, text: str):\n    \"\"\"Set the input display's text.\n\n    Set the output display's text, when selecting something from\n    the browser, for instance\n\n    Parameters\n    ----------\n    text: str\n        the text to be displayed\n    \"\"\"\n    self.lineEdit_oFile.setText(text)\n    self.lineEdit_oFile.setFocus()\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.display_iFile_Text","title":"<code>display_iFile_Text()</code>","text":"<p>Get the input display's text.</p> <p>Returns:</p> Type Description <code>lineEdit_iFile.text(): str</code> <p>the text in the display</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def display_iFile_Text(self) -&gt; str:\n    \"\"\"Get the input display's text.\n\n    Returns\n    -------\n    lineEdit_iFile.text(): str\n        the text in the display\n    \"\"\"\n    return self.lineEdit_iFile.text()\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.display_oFile_Text","title":"<code>display_oFile_Text()</code>","text":"<p>Get the output display's text.</p> <p>Returns:</p> Type Description <code>lineEdit_oFile.text(): str</code> <p>the text in the display</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def display_oFile_Text(self) -&gt; str:\n    \"\"\"Get the output display's text.\n\n    Returns\n    -------\n    lineEdit_oFile.text(): str\n        the text in the display\n    \"\"\"\n    return self.lineEdit_oFile.text()\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.open_iFileDialog","title":"<code>open_iFileDialog()</code>","text":"<p>Create the browser dlg to select the input file.</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def open_iFileDialog(self):\n    \"\"\"Create the browser dlg to select the input file.\"\"\"\n    ifile_dialog = QFileDialog(self)\n    ifile_dialog.setWindowTitle('Open Input File')\n    ifile_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptOpen)\n    self._iFileName = self.display_iFile_Text()\n    if self._iFileName == '':\n        ifile_dialog.setDirectory(self._defaultPath)\n    else:\n        try:\n            self._funcionesLeer.check_path(self._iFileName)\n        except IOError:  # as error:\n            ifile_dialog.setDirectory(self._defaultPath)\n        else:\n            ifile_dialog.setDirectory(self._iFileName)\n\n    ifile_dialog.setNameFilter('Text (*.inx *.dat *.txt)')\n    ifile_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)\n    ifile_dialog.setViewMode(QFileDialog.ViewMode.Detail)\n\n    if ifile_dialog.exec():\n        # As\u00ed se guarda el nombre del archivo y la ruta\n        self._iFileName = ifile_dialog.selectedFiles()\n        self.set_iFile_DisplayText(self._iFileName[0])\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.display_temp_Text","title":"<code>display_temp_Text()</code>","text":"<p>Get the temperature display's text.</p> <p>Returns:</p> Type Description <code>lineEdit_Temp.text(): str</code> <p>the text in the display</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def display_temp_Text(self) -&gt; str:\n    \"\"\"Get the temperature display's text.\n\n    Returns\n    -------\n    lineEdit_Temp.text(): str\n        the text in the display\n\n    \"\"\"\n    return self.lineEdit_Temp.text()\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.open_oFileDialog","title":"<code>open_oFileDialog()</code>","text":"<p>Create the browser dlg to select the output file.</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def open_oFileDialog(self):\n    \"\"\"Create the browser dlg to select the output file.\"\"\"\n    ofile_dialog = QFileDialog(self)\n    ofile_dialog.setWindowTitle(\"Set Output File Name\")\n    ofile_dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)\n    self._oFileName = self.display_oFile_Text()\n    if self._oFileName == '':\n        ofile_dialog.setDirectory(self._defaultPath)\n        try:\n            self._funcionesLeer.check_path(self._oFileName)\n        except IOError:  # as error:\n            ofile_dialog.setDirectory(self._defaultPath)\n        else:\n            ofile_dialog.setDirectory(self._oFileName)\n\n    ofile_dialog.setNameFilter(\"Text (*.csv)\")\n    ofile_dialog.setViewMode(QFileDialog.ViewMode.Detail)\n\n    if ofile_dialog.exec():\n        # As\u00ed se guarda e nombre del archivo y la ruta\n        self._oFileName = ofile_dialog.selectedFiles()\n        self.set_oFile_DisplayText(self._oFileName[0])\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.updateRadioSelection","title":"<code>updateRadioSelection()</code>","text":"<p>Check the radio buttons.</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def updateRadioSelection(self) -&gt; bool:\n    \"\"\"Check the radio buttons.\"\"\"\n    # get the radio button the send the signal\n    rb = self.sender()\n    # check if the radio button is checked\n    if rb.isChecked():\n        self._rb_value = 'cheked'\n        self._instrument = rb.text()\n    return True\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.updateCheckBoxState","title":"<code>updateCheckBoxState()</code>","text":"<p>Save the checkbox's value.</p> <p>Also enables/disables the temperature lineEdit.</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def updateCheckBoxState(self):\n    \"\"\"Save the checkbox's value.\n\n    Also enables/disables the temperature lineEdit.\n    \"\"\"\n    if self.checkBox_Susceptivility.isChecked() is True:\n        self.label_Temp.setDisabled(False)\n        self.lineEdit_Temp.setDisabled(False)\n        self.label_K.setDisabled(False)\n        self._susceptivility_checked = True\n    if self.checkBox_Susceptivility.isChecked() is False:\n        self.label_Temp.setDisabled(True)\n        self.lineEdit_Temp.setDisabled(True)\n        self.label_K.setDisabled(True)\n        self._susceptivility_checked = False\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.DLG.sortAndSave","title":"<code>sortAndSave()</code>","text":"<p>Sort input data and save as csv.</p> <p>Check if all the conditions meet to sort and save the data, and if so, proceeds.</p> <p>Other Parameters:</p> Name Type Description <code>_iFileName</code> <p>to save the input file name and path</p> <code>_oFileName</code> <p>to save the output file name and path</p> <code>_current_date</code> <p>to save the current date and time when displaying a msg</p> <code>_last_msg</code> <p>to save the last message displayed in the log textBrowser</p> <code>qvalue</code> <p>to save the Q values</p> <code>energy</code> <p>to save the Energy array for each Q</p> <code>scatInt</code> <p>to save the scattered intensity for each Q</p> <code>err</code> <p>to save the measured error in the intensity for each Q</p> <code>iFile</code> <p>to save the opened input file</p> <code>path</code> <p>to save the path</p> <code>dfS</code> <p>to save the S(Q, E) in a matrix form</p> <code>dfChiSorted</code> <p>to save the Chi (Q, E) in a matrix from</p> <code>temp</code> <p>to save the numeric value of the temperature</p> <p>Raises:</p> Type Description <code>OSError</code> <p>if the path or the file does not exist</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def sortAndSave(self) -&gt; bool:\n    \"\"\"Sort input data and save as csv.\n\n    Check if all the conditions meet to sort and save the data,\n    and if so, proceeds.\n\n    Other parameters\n    ----------------\n    _iFileName: str\n        to save the input file name and path\n    _oFileName: str\n        to save the output file name and path\n    _current_date: str\n        to save the current date and time when displaying a msg\n    _last_msg: str\n        to save the last message displayed in the log textBrowser\n    qvalue: list[float]\n        to save the Q values\n    energy: list[list[float]]\n        to save the Energy array for each Q\n    scatInt: list[list[float]]\n        to save the scattered intensity for each Q\n    err: list[list[float]]\n        to save the measured error in the intensity for each Q\n    iFile: _io.TextIOWrapper\n        to save the opened input file\n    path: str\n        to save the path\n    dfS: pandas.DataFrame\n        to save the S(Q, E) in a matrix form\n    dfChiSorted: pandas.DataFrame\n        to save the Chi (Q, E) in a matrix from\n    temp: float\n        to save the numeric value of the temperature\n\n    Raises\n    ------\n    OSError\n        if the path or the file does not exist\n    \"\"\"\n    # Lo primero deber\u00eda comprobar que los valores de los edit de\n    # los files existen.\n    self._iFileName = self.display_iFile_Text()\n    self._oFileName = self.display_oFile_Text()\n\n    # Necesito comprobar que alg\u00fan radio button est\u00e1 seleccionado\n    if self._rb_value == 'unchecked':\n        self._current_date = QDateTime.currentDateTime().\\\n            toString('hh:mm:ss')\n        self._last_msg = self._current_date + ': Select instrument\\n'\n        self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n        self.textBrowser_log.insertPlainText(self._last_msg)\n        return False\n\n    try:\n        self._funcionesLeer.check_path(self._iFileName)\n    except IOError as error:\n        self._current_date = QDateTime.currentDateTime().\\\n            toString('hh:mm:ss')\n        self._last_msg = self._current_date + ': ' + \\\n            str(error.strerror) + 'Enter a valid input path\\n'\n        self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n        self.textBrowser_log.insertPlainText(self._last_msg)\n        return False\n    else:\n        # \"Declaro\" variables para guardar los datos\n        qvalue: list[float]\n        energy: list[list[float]]\n        scatInt: list[list[float]]\n        err: list[list[float]]\n\n        if (self._instrument != 'LET'):\n            iFile: _io.TextIOWrapper\n            # LLamo a la funci\u00f3n que abre el fichero con las medidas\n            try:\n                iFile = self._funcionesLeer.open_iFile(self._iFileName)\n            except OSError as error:\n                self._current_date = QDateTime.currentDateTime().\\\n                    toString('hh:mm:ss')\n                self._last_msg = self._current_date + ': ' + \\\n                    str(error.strerror) + '\\n'\n                self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                self.textBrowser_log.insertPlainText(self._last_msg)\n                return False\n            else:\n                # Llamo a la funci\u00f3n que me guarda los datos en listas\n                qvalue, energy, scatInt, err = self._funcionesLeer.\\\n                    read_from_ifile(iFile, self._instrument)\n                # Y cierro el archivo de datos\n                self._funcionesLeer.close_iFile(iFile)\n        else:\n            qvalue, energy, scatInt, err = self._funcionesLeer.\\\n                leer_de_LET(self._iFileName)\n            # corto el nombre del archivo y lo junto con el path otra vez\n            # para poder nombrar las columnas en los data frames\n            path: str\n            path = os.path.dirname(self._iFileName)\n            self._iFileName = path + \\\n                self._funcionesLeer.fileNameDropLET(self._iFileName)\n\n        # Defino el Data Frame para guardar S(Q,E)\n        dfS: pd.DataFrame\n        # Llamo a la funci\u00f3n que me guarda los datos en DataFrame de Pandas\n        dfS = self._funcionesLeer.data_to_pandas_df(\n            self._iFileName, qvalue, energy, scatInt, err)\n\n        # Por \u00faltimo, exporto S(Q,E) a  CSVs\n        try:\n            self._funcionesLeer.check_path(self._oFileName)\n        except IOError as error:\n            self._current_date = QDateTime.currentDateTime().\\\n                toString('hh:mm:ss')\n            self._last_msg = self._current_date + ': ' + \\\n                str(error.strerror) + 'Enter a valid output path\\n'\n            self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n            self.textBrowser_log.insertPlainText(self._last_msg)\n            return False\n        else:\n            try:\n                self._funcionesLeer.save_data_to_csv(self._oFileName, dfS)\n            except IOError:\n                self._current_date = QDateTime.currentDateTime().\\\n                    toString('hh:mm:ss')\n                self._last_msg = self._current_date + \\\n                    ': Error exporting data to CSV!\\n'\n                self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                self.textBrowser_log.insertPlainText(self._last_msg)\n                return False\n            else:\n                self._current_date = QDateTime.currentDateTime().\\\n                    toString('hh:mm:ss')\n                self._last_msg = self._current_date + \\\n                    ': Data succesfully exported to CSV!\\n'\n                self.textBrowser_log.insertPlainText(self._last_msg)\n\n        if self._susceptivility_checked is True:\n            # Guardo el valor de la temperatura\n            self._temperature = self.display_temp_Text()\n            temp: float\n            try:\n                temp = float(self._temperature)\n            except ValueError:\n                self._current_date = QDateTime.currentDateTime().\\\n                    toString('hh:mm:ss')\n                self._last_msg = self._current_date + \\\n                    ': Enter a valid temperature\\n'\n                self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                self.textBrowser_log.insertPlainText(self._last_msg)\n                return False\n\n            # Defino el DataFrame donde voy a guardar la susceptibilidad\n            dfChiSorted: pd.DataFrame\n            # Llamo a la funci\u00f3n que me calcula Chi a partir de E y S(Q,E)\n            # y me lo guarda en un DataFrame\n            dfChiSorted = self._funcionesLeer.chi_from_S(temp, qvalue, dfS)\n            # Por \u00faltimo, exporto Chi(Q,E) a  CSVs\n            try:\n                self._funcionesLeer.check_path(self._oFileName)\n            except IOError as error:\n                self._current_date = QDateTime.currentDateTime().\\\n                    toString('hh:mm:ss')\n                self._last_msg = self._current_date + ': ' + \\\n                    str(error.strerror) + 'Enter a valid output path\\n'\n                self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                self.textBrowser_log.insertPlainText(self._last_msg)\n                return False\n            else:\n                try:\n                    self._funcionesLeer.save_chi_data_to_csv(\n                        self._oFileName, dfChiSorted)\n                except IOError:\n                    self._current_date = QDateTime.currentDateTime().\\\n                        toString('hh:mm:ss')\n                    self._last_msg = self._current_date + \\\n                        ': Error exporting susceptivility data to CSV!\\n'\n                    self.textBrowser_log.setTextColor(QColor(255, 51, 0))\n                    self.textBrowser_log.insertPlainText(self._last_msg)\n                    return False\n                else:\n                    self._current_date = QDateTime.currentDateTime().\\\n                        toString('hh:mm:ss')\n                    self._last_msg = self._current_date + \\\n                        ': Susceptivility data exported to CSV!\\n'\n                    self.textBrowser_log.insertPlainText(self._last_msg)\n    return True\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.QENStoCSV","title":"<code>QENStoCSV</code>","text":"<p>QENStoCSV's controller class.</p> <p>Conects the signals with the actions.</p> <p>Attributes:</p> Name Type Description <code>view</code> <code>DLG</code> <p>is the class of dlg window to acces the elements sendig out the signals.</p> <p>Methods:</p> Name Description <code>_connectSignalsAndSlots</code> <p>Connects signals and slots</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>class QENStoCSV:\n    \"\"\"QENStoCSV's controller class.\n\n    Conects the signals with the actions.\n\n    Attributes\n    ----------\n    view: DLG\n        is the class of dlg window to acces the elements\n        sendig out the signals.\n\n    Methods\n    -------\n    _connectSignalsAndSlots()\n        Connects signals and slots\n    \"\"\"\n\n    def __init__(self, view):\n        \"\"\"Class constructor.\"\"\"\n        self._view = view  # A view le voy a asignar la clase de la ventana\n        self._connectSignalsAndSlots()\n\n    # Esta funci\u00f3n conecta los botones de la interface con las acciones del\n    # programa\n    def _connectSignalsAndSlots(self):\n        self._view.pushButton_iFile.clicked.connect(\n            self._view.open_iFileDialog)\n        self._view.pushButton_oFile.clicked.connect(\n            self._view.open_oFileDialog)\n        self._view.pushButton_Save.clicked.connect(self._view.sortAndSave)\n        self._view.radioButton_IN5.toggled.connect(\n            self._view.updateRadioSelection)\n        self._view.radioButton_IN16B.toggled.connect(\n            self._view.updateRadioSelection)\n        self._view.radioButton_FOCUS.toggled.connect(\n            self._view.updateRadioSelection)\n        self._view.radioButton_LET.toggled.connect(\n            self._view.updateRadioSelection)\n        self._view.checkBox_Susceptivility.stateChanged.connect(\n            self._view.updateCheckBoxState)\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.QENStoCSV.__init__","title":"<code>__init__(view)</code>","text":"<p>Class constructor.</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def __init__(self, view):\n    \"\"\"Class constructor.\"\"\"\n    self._view = view  # A view le voy a asignar la clase de la ventana\n    self._connectSignalsAndSlots()\n</code></pre>"},{"location":"reference/#QENS_to_csv_pkg.app_QENStoCSV_Dlg.main","title":"<code>main()</code>","text":"<p>Run the App.</p> Source code in <code>QENS_to_csv_pkg\\app_QENStoCSV_Dlg.py</code> <pre><code>def main():\n    \"\"\"Run the App.\"\"\"\n    app = QApplication(sys.argv)\n    dlg = DLG()\n    dlg.show()\n    QENStoCSV(view=dlg)\n    sys.exit(app.exec())\n</code></pre>"},{"location":"reference/#more-documentation","title":"More documentation","text":"<p>See also FuncionesLeer</p>"}]}